[{"title":"总结一下我看过的电视-电影-书等","date":"2019-01-06T02:36:11.000Z","path":"2019/01/06/summaryforyear.html","text":"简介总结一下我看过的经典的、打动人心的电视，电影，书等电视老友记老爸老妈浪漫史请回答 1988神秘博士星际迷航电影肖申克的救赎触不可及返老还童v~字~仇~杀~队消失的爱人勇敢的心香水-一个谋杀犯的故事~熔~炉~（韩国）出~租~车~司~机（韩国）1987~黎~明~到~来~的~那~一~天（韩国）疯狂的石头阳光灿烂的日子霸王别姬书雁飞残月天蛮荒三部曲银河帝国系列三体游戏三位一体","tags":[{"name":"总结","slug":"总结","permalink":"http://wuyang910217.github.io/tags/总结/"}]},{"title":"博客中使用gitment添加评论功能","date":"2019-01-03T11:33:15.000Z","path":"2019/01/03/gitment.html","text":"简介准备重新开始使用博客 hexo 的命令都快忘完了 记录一下gitment 评论使用 gitment 提供的评论功能，评论是以 issue 的形式记录在 github 仓库里地址：https://github.com/wuyang910217/blog-comments/issueshexo 常用命令首先需要安装 hexo npm i -g hexo创建新文章：hexo new post-title 后面不加.md部署到 github 和 gitlab12345678# 存为shell脚本git add .git commit -m 'update'git push origin masterhexo cleanhexo ghexo d文章模板在scafflods/post.md添加以下内容1234567891011121314151617181920212223242526272829303132333435363738---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: [Others]tags: [default]---# 简介&gt; Space: the final frontier. These are the voyages of the starship Enterprise. Its five-year mission: to explore strange new worlds, to seek out new life and new civilizations, to boldly go where no man has gone before.&lt;!--more--&gt;## section1&gt; Space: the final frontier. These are the voyages of the starship Enterprise. Its five-year mission: to explore strange new worlds, to seek out new life and new civilizations, to boldly go where no man has gone before.## section21. Space: the final frontier.2. These are the voyages of the starship Enterprise.3. Its five-year mission: to explore strange new worlds,4. to seek out new life and new civilizations,5. to boldly go where no man has gone before.## section3- Space: the final frontier.- These are the voyages of the starship Enterprise.- Its five-year mission: to explore strange new worlds,- to seek out new life and new civilizations,- to boldly go where no man has gone before.## 总结[Link](https://wuyang910217.github.io)![Image]()源码地址部署到 github 的内容是 html 格式的，而我们的博客源文件（包括 hexo 配置 PWA 支持 主题修改等）需要 push 到私有仓库我的博客源文件（hexo 整个项目）是存在 gitlab 上的","tags":[{"name":"gitment","slug":"gitment","permalink":"http://wuyang910217.github.io/tags/gitment/"}]},{"title":"博客文章模板","date":"2017-04-10T13:27:39.000Z","path":"2017/04/10/test.html","text":"简介Space: the final frontier. These are the voyages of the starship Enterprise. Its five-year mission: to explore strange new worlds, to seek out new life and new civilizations, to boldly go where no man has gone before.section1Space: the final frontier. These are the voyages of the starship Enterprise. Its five-year mission: to explore strange new worlds, to seek out new life and new civilizations, to boldly go where no man has gone before.section2Space: the final frontier.These are the voyages of the starship Enterprise.Its five-year mission: to explore strange new worlds,to seek out new life and new civilizations,to boldly go where no man has gone before.section3Space: the final frontier.These are the voyages of the starship Enterprise.Its five-year mission: to explore strange new worlds,to seek out new life and new civilizations,to boldly go where no man has gone before.总结Link","tags":[{"name":"default","slug":"default","permalink":"http://wuyang910217.github.io/tags/default/"}]},{"title":"Mac上的实用软件","date":"2017-03-09T03:47:19.000Z","path":"2017/03/09/mac-useful-software.html","text":"简介Mac上的实用软件程序相关vscode 编辑器Sublime text3 编辑器Virtual box 虚拟机Postman 编写和测试APIRobomongo mongo的图形化显示Mongochef mongo的图形化显示Dash 查询常见语言和程序的文档APIiterm2 终端效率Spotlight 系统自带 cmd+空格Alfred3Magnet 组织窗口Manico 程序间快速切换jietu 腾讯出品Popclip 系统级 选中文字后出现多项操作选项Bartender2 把mac菜单栏中的图标统一管理Paste 储存复制的内容，用于其他的地方粘贴Jitouch 强大的手势CheatSheet 显示快捷键系统iStat Menus 显示系统信息，CPU，内存等坚果云 云端同步1password 密码管理Movist 视频播放工具云梯vpn mac客户端ShadowsocksX vpn代理Usage 记录软件使用时间Timing 更强大 记录软件使用时间Flux 根据时间调整屏幕亮度Fliqlo 屏保 显示时间APP Cleaner/Dr. Cleaner/CleanMyMac3 系统清理tickeys 模拟机械键盘声音amphetamine 保持mac不休眠Boom2 系统级音频增强工具Folx go 下载工具 集成于浏览器中BetterZip 解压软件SiteSucker 扒站利器Sip 屏幕颜色采集器LyricsX 给itunes显示歌词写作办公为知笔记Quiver 程序员用markdown笔记MacDown 书写markdownOmniFocus 专注 效率 代办事项Fantastical2 好用的日历提醒Airmail3 邮件客户端PDF expert pdf阅读Reeder rss客户端Day one 日记本Klib 整理kindle中标注的内容，可转为markdown其他Mockplus 原型图设计Sketch UI设计MindNode 思维导图Blender 3D设计软件Noizio 模拟常见声音 如雨声Tweetbot Twitter客户端xScope 测量屏幕等工具集合Charles 抓包工具Instacast/Downcast 收听podcast播客ScreenFlow 录屏工具Popcorn time 观看tvtelegram 聊天工具gimp 开源图片处理工具inkscape 矢量图绘制软件Krita 手绘软件","tags":[{"name":"mac","slug":"mac","permalink":"http://wuyang910217.github.io/tags/mac/"}]},{"title":"Meteor中使用antd/antd-mobile","date":"2016-12-14T01:58:48.000Z","path":"2016/12/14/use-ant-design-in-meteor.html","text":"简介我们的项目使用的技术栈是Meteor和React全家桶，前端UI库用的是Bootstrap．最近经人介绍了解到阿里蚂蚁金服前端团队出品的antd和antd-mobile，基于React和TypeScript开发，提供了很多实用的组件，基本满足所有常见场景的前端设计和实现．其中antd-mobile是antd的移动端实现，支持React-Native．传送门：antdantd-mobile在Meteor中使用antd在Meteor中使用antd很简单，只需按照其官方文档安装antd babel-plugin-import，并配置.babelrc文件．如下：123456789101112131415161718meteor npm install --save antdmeteor npm install --save-dev babel-plugin-import//.babelrc文件&#123; \"plugins\": [ [\"import\", [ &#123; \"libraryName\": \"antd\", \"style\": \"css\" &#125; ]] ], \"presets\": [ \"es2015\", \"react\", \"stage-0\" ]&#125;其中style一项，填写为true会报错，填写为css则正常．然后在项目中我们就可以直接引入各个组件，这个插件会自动按需加载需要的js和css文件．简单例子如下：12345678910111213import React, &#123; Component &#125; from 'react-dom';import &#123; DatePicker, Button &#125; from 'antd';export default class Test extends Component &#123; render()&#123; return ( &lt;div&gt; &lt;DatePicker /&gt; &lt;Button type='primary'&gt;Sure&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;对于Meteor React这种单页面应用，分页很令人头疼，一般都是做成无限向下滚动，没有分页功能．而antd提供了Pagination组件，并且在展示很多数据的Table组件里，只需添加一个参数，就能实现分页功能，如下：1&lt;Table columns=&#123;columns&#125; dataSource=&#123;data&#125; pagination=&#123;&#123; pageSize: 30 &#125;&#125; /&gt;遇到的一些问题在使用Popconfirm组件时，按照其文档的写法，一直都是刷新页面后，其组件会自动执行，比如我在测试时，添加了100个用户，并提供了删除命令，用Popconfirm组件包裹，本来是当管理员点击删除，并确定后，再删除用户，可结果是刷新页面后，删除命令自动执行了，不到２秒，把100个用户全都删除了．原本写法：123456789&lt;Popconfirm title=\"确定要删除吗？\" onConfirm=&#123;this.handleConfirm(user._id)&#125; &gt; &lt;a href='#'&gt;删除&lt;/a&gt;&lt;/Popconfirm&gt;handleConfirm(id)&#123; const &#123; dispatch, deleteUser &#125; = this.props; dispatch(deleteUser(id));&#125;一开始以为要加event事件，onConfirm={(e) =&gt; this.handleConfirm(e, user._id)}，然后在handleConfirm(e, id){}里添加e.preventDefault()，尝试后发现不行，一直报错．最后又尝试了好久，发现要这样写：123456789&lt;Popconfirm title=\"确定要删除吗？\" onConfirm=&#123;() =&gt; this.handleConfirm(user._id)&#125; &gt; &lt;a href='#'&gt;删除&lt;/a&gt;&lt;/Popconfirm&gt;handleConfirm(id)&#123; const &#123; dispatch, deleteUser &#125; = this.props; dispatch(deleteUser(id));&#125;只需用箭头函数包裹，不用传递event事件，完美解决．在Meteor中使用antd-mobileantd-mobile目前含有web版和react-native版，并且没有分开，导致很容易出现依赖问题，比如我不需要react-native，但是它一直提示需要安装react-native，关键是安装后，仍然报错，让人崩溃．在Meteor中使用antd-mobile，麻烦很多，其实不只是Meteor,其Github issues里有大量类似的问题，总结起来两大类，见issues #602:找不到模块antd-mobile或者找不到引入的具体组件提示依赖react-native其给出了具体的办法，但是仍然不能成功，现阶段解决办法就是在项目中直接引入其dist目录下的css和js文件．如下：1import &#123; List, Button, Flex &#125; from &apos;antd-mobile/dist/antd-mobile&apos;;总结antd没有响应式设计，在移动端要使用antd-mobileantd-mobile目前还不如antd成熟","tags":[{"name":"meteor","slug":"meteor","permalink":"http://wuyang910217.github.io/tags/meteor/"},{"name":"antd","slug":"antd","permalink":"http://wuyang910217.github.io/tags/antd/"}]},{"title":"哲学家都干了些什么","date":"2016-11-24T00:47:12.000Z","path":"2016/11/24/what-have-done-by-philosopher.html","text":"简介《哲学家都干了些什么》作者林新浩，讲述史上最严谨又最不严肃的哲学史．在被告人是否有罪这个问题上,陪审团是负责裁决的主角。法官才是陪衬,只能做做解释法律、引导庭审、剔除非法证据、维持法庭秩序之类的“服务”工作。让我们难以理解的是,美国陪审团的成员都是普通老百姓。法庭对他们的学历水平、法律知识几乎没有任何要求。一个小学学历、没学过法律的人,也有权决定嫌疑人是不是有罪。但在美国人看来,这种制度有个很大的好处,就是能保证每个案件的裁断都符合大众的道德观。这能避免法律人士凭着专业优势玩弄法律条文,避免由于法官个人好恶左右案情,也能用来对抗失去民心的恶法。不难理解,理论上陪审团成员越多,断案就越客观。出于成本考虑,今天美国的陪审团只有12个人。苏格拉底的案件常常被现代人当作“民主暴政”的例子,说明“多数人的民主”在错误的引导下也会作出邪恶的判决。但是芝诺有一个著名的比喻,说人的知识好像一个圆圈,知识越多,圆圈的周长就越长,就会发现自己越无知。我们普通人为什么要研究哲学?我在本书前言里说了,这关系到我们个人的哲学问题是:人生的意义是什么?奢侈是什么?贵而无用就叫奢侈。而哲学这玩意儿超级无用。所以那个时代的人们一听说你是学哲学的,都狂羡慕。人家想:这人家里得多富裕才敢往哲学身上糟践钱啊。哲学的发展非但不是一马平川,反而在好几个世纪里都处于命悬一线的危险境地。一不留神,哲学前辈们的努力就会从地球上彻底绝迹。这底比斯圣队非常有名,最大的特点是所有士兵都是一对一对的同性恋。这支部队都是恋人兵,打仗的时候谁都不肯后退,战斗力超强。当这支部队被马其顿王子击溃后,整个雅典联军也就溃败了。雅典从此落入了马其顿人之手。二十年后,亚历山大的军队所向披靡,最终让马其顿横跨欧亚非三洲,成为人类古代史上面积最大的帝国之一,称为亚历山大帝国。王国维说:“可爱者不可信,可信者不可爱。”是的,和苏格拉底、柏拉图齐名的亚里士多德不是雅典人,是马其顿人。亚历山大的征服对哲学来说是一件好事。 随着亚历山大的铁骑,希腊的哲学著作得以遍布东欧、北非以及中亚,散布下无数思辨的火种。如果没有这一步铺垫,不久以后,希腊哲学就会彻底从地球上消失。当然,我们知道,罗马宽容政策的后果直接导致了后来的欧洲再也没能形成像中国那样统一的大国,而是永远分成了多个民族国家。 对于欧洲的历史选择,有人说好,有人说不好,这些我们不讨论。 我只知道对于知识来说,宽容永远代表着光明。罗马帝国成立之初的文化界,宛如咱们春秋时代的百家争鸣。争鸣的地方常常是在城市中心的广场上。不同学派的人们可以自由宣讲、辩论自己的观点,那是文化人最幸福的时代。罗马帝国在文化和宗教上奉行的是宽容政策。 比如罗马征服了很多蛮族,那些蛮族原本有自己的神灵。为此,罗马人建了极其宏伟的“万神殿”,把各个蛮族的神灵都供奉到里面。犹太教和基督教并不是同一个宗教。首先是在犹太人中产生了犹太教,而基督教是从犹太教中发展来的。在对待经文上,两者都信奉《旧约》,但只有基督教相信《新约》。《旧约》和《新约》的区别大致在于,一个是记录耶稣降生之前的事,一个是记录之后的事。保罗做的最重要的一件事,就是向犹太人以外的民族传播基督教。这是一项很了不起的工作。在保罗之前,基督教大体上只限于犹太人自己信仰。因了保罗的传教,才使得基督教后来成为世界性的大宗教。历史上有一个规律,在斗争中,哲学总站在弱者的一方。保罗有深厚的哲学功底,他将哲学的思维方式应用到传教中,撰写了大量的神学文章。这些文字后来被称作《保罗书信》,成为《新约》的重要组成部分。好的地方在于,这回是显了哲学的大能耐了。基督教对世界影响深远,起步阶段的汗马功劳就是哲学立下的。不好的地方在于,宗教和哲学在根子上是无法协调的。宗教要求信仰,哲学要求怀疑,两者相悖。王尔德说过:“我能抵抗一切,除了诱惑。”奥古斯丁的贡献之一,就是解决了一个长久困扰基督教的逻辑漏洞: 《圣经》说上帝是全知、全能和全善的,那为什么会允许人间存在这么多丑恶和痛苦?更具体地说,上帝是善的,而上帝的善表现在上帝对人类的行为要进行公正的赏罚。既然要赏罚,前提是人类必须拥有自由意志,必须有能力自己选择行善还是作恶,否则人类就不应该对自己的行为负责。有个教父哲学家有一句名言:“上帝之子死了,虽然是不合理的,但却是可以相信的。埋葬以后又复活了,虽然是不可能的,但却是肯定的。正因为荒谬,所以我才相信。”有句俗话叫“能用钱解决的问题都不是问题”,其实还可以说一句话:“必须用暴力解决的问题都是解决不了的问题”。换句话说,垄断了对权威的解释,就等于垄断了一切。也正因为有了印刷术,欧洲人才有了众多崭新的思想,有了哲学的复兴,有了科学的崛起,有了现代文明的一切:思想自由、理性、怀疑精神、科学、光明的未来。威尔・杜兰的话说:“每一次收获乃是大地的奇迹与苍穹之杰作”。欧洲基督教分成了两大派:罗马一方被称为天主教;路德一方被称为新教。另外,东边的罗马帝国在此之前还搞了一个东正教。俗话说“牛打江山马坐殿”。革命的理论者和掌权者常常不是同一个人。就像卢梭成就了罗伯斯庇尔,路德成就的是加尔文。加尔文像他的敌人——罗马的天主教皇那样——当上了新教的教皇,日内瓦成了新教的罗马。当邻居大妈默念“人的命天注定”的时候,她信奉的是宿命论和决定论;当朋友在酒桌上劝你“赚钱有什么用,钱再多早晚也是一个死”的时候,他讲的是虚无主义;当人生感悟型的散文告诫你“当下最重要,活出你自己”的时候,它其实就是萨特的代言人。为什么当年的苏格拉底那么招人讨厌,却能被后人奉为圣贤。因为他的怀疑是理性文明的开端和标尺。所有的思想都要因他的怀疑而诞生,最后还要能经得住他的怀疑才算合格。荷兰在近代欧洲第一个取消了独裁者,完全采用议会投票的方式处理政务。这种政体从罗马屋大维结束民主制度以来,已经很多年没有了。此时的荷兰也不能叫作“荷兰王国”了,而改叫“荷兰共和国”。“我思”和“我在”不是因果关系,而是推理演绎的关系。即:从前者为真可以推导出后者为真。也就是从“我思”为真,可以推导出“我在”为真。而不是说“我不思”的时候就“我不在”了,在不在我们不知道。安德罗尼柯起这个metaphysics的原本目的,应该是他没有现成的词汇可用,于是就说这部分著作是“编排在《物理学》之后的内容”。但这个词的含义也可以引申成“物理学之后的学问”。也就是说,形而上学研究的是那些高于物理学的、看不见、摸不着的学问。 这就是“形而上学”这个词最早的来历。“形而上学”的中文译名也很棒,称得上是中文翻译史上最棒的译名之一。中文典出《易经》:“形而上者谓之道,形而下者谓之器。”我们现在所说的“形而上学”,可以简单地理解成是用理性思维去研究那些能统一世间一切问题的“大道理”二元论能帮助我们的关键是:我们在自己的精神世界里是无敌的,而一切体验归根到底都是精神体验。笛卡尔说过:“不管多么荒谬、多么不可置信的事,无一不是这个或那个哲学家主张过的。”按照笛卡尔的设计,斯宾诺莎把哲学研究推上了一条井然有序的道路。其他的哲学家可以像做数学研究那样,发明新的体系,创造新的定理。或者按照逻辑规则修改、补充前人的成果。如此,哲学成果也就必然会越来越完善,越来越接近真理。培根强调要重视事实。而在事实的基础上进一步形成科学知识,就要靠归纳法了。事实上,我们今天取得的所有科学成就,都是综合使用归纳法和演绎推理的结果。对于科学家们来说,数学是通向真理的桥梁,但不是真理本身。洛克也承认人的本能是天生的,比如直觉之类。但洛克认为,这些本能就和动物捕食、生存的本能一样,是一种生理、心理上的习惯而已,并不是什么比客观世界高一等的理性,更不可能由此建立起一个哲学世界来。顺便一说,洛克在政治上的贡献也很大。他是一个自由主义者,在皇权当道的时代就提出了“人人生而平等”“天赋人权”等概念。他的理论影响深远,美国的《独立宣言》甚至直接引用了洛克的著作中的话。笛卡尔、斯宾诺莎代表的数学家派,被称为“理性主义”。 在归纳法里,最重要的是实验数据,是观测结果,它们是科学理论的基础和证据。这些东西可以用一个词来统称:经验。 所以洛克代表的科学家派被称为“经验主义”。假如哲学是一座通向终极真理的巴别塔的话,那么理性主义者的塔高耸入云,每搭建一次,都似乎马上可以触摸到天堂。但是这座塔的根基却是几根破木头,经验主义者们经常溜达过来,随便踹上几脚,这座塔就塌了。 经验主义不同,他们的塔盖得极为结实。但是由于能力有限,他们只能零零散散地在各地建造一些矮塔,这些塔既连不到一块,又没法盖得很高。因此经验主义者们的塔虽然结实,却根本没法满足人类的要求,盖得再多也没有用。如果不怕被指责牵强的话,我们还可以说,重视个别经验、对独断论充满警惕之心的经验主义,是英国人古板的民族性格的体现。而试图从万物根本一劳永逸地建立一个大一统理论的理性主义,正是荷兰和法国浪漫精神的代表。莱布尼茨在给他的贵族小姐们解释这件事的时候,说了一句名言:“世上没有两片树叶是相同的。”没有他,以英国小小的面积,要想对抗整个欧洲大陆恐怕是痴人说梦。而有了他,英国学者一下子就成为全世界最权威、最有话语权的人。 这个威震天下的神仙就是牛顿。牛顿,旷世天才,伟大的物理学家、数学家、天文学家、哲学家、神学家、炼金术士、小心眼儿、世界末日预测者。 ——对,你没听错,牛顿晚年通过复杂的公式,计算出了世界末日的具体时间,就在2060年。牛顿的学霸行为还造成了另一个后果。莱布尼茨的微积分符号比牛顿的更简单易用,当时整个欧洲都采用了莱布尼茨的符号,包括我们今天用的也是莱布尼茨的。但英国出于民族主义,坚持使用牛顿符号,使得英国和欧洲大陆之间的科学交流受到了严重的阻碍。一百多年后,英国实在绷不住了,才放弃了难用的牛顿符号,改用莱布尼茨的。这一百多年的死要面子给英国学术的发展造成了巨大的损失。但是这简单的三句话,却可以解释小到一块石子、大到一颗星球,乃至宇宙中一切一切物体的运动规律。而且以当时的观测条件,预测的结果很精确。就算是向来被人们当作神祇的群星,牛顿说它们下一步该出现在哪里,它们就出现在哪里。1727年牛顿逝世后,被安葬在英国最高级别、埋葬众多英国国王的威斯敏斯特大教堂里。英国给他举行的是国葬,送葬队伍绵延好几英里,为他抬棺材的是两位公爵、三位伯爵和一位大法官。用物理学来解释包括人类意识在内的整个世界,这种观点就叫作“机械论”。机械论很好理解,我们在学校的时候都受过辩证唯物主义的训练。机械论就是除掉了辩证法之后的唯物主义,也可以叫作“机械唯物主义”。到了这时,人类理解、设计社会也可以像用力学去计算天体一样简单便捷。人类可以按照这些公式,设计出一个完美的社会。我们可以自信满满地保证每一个社会政策都是对人类利益的最优解,就像我们可以保证每一台新发明的机械都是对力学的最优解一样。那样可以避免多少人间悲剧啊。既然一切都是决定好的,那我们为什么还要努力奋斗,为什么还要劳动?人生还有什么意义?如果人类只是被操控的木偶,活着听从因果律摆布,死后化为虚无。那还有什么人生意义呢?所以,你觉得自己是自由的,这感觉本身也是被因果律决定好的。连你试图反抗因果律这行为本身,也是被因果律决定的。决定论虽然会导致一些很荒谬的结果,导致人对待生活的消极态度。但决定论也能起到很强的安慰作用。唯我论把人看得最大,可以安慰人。机械论和决定论把人看得渺小,也同样可以安慰人。从逻辑上还可以这么解释。两件事连在一起发生,发生了一回,经验只能告诉我们这是偶然的。那么无论这两件事连在一起发生了多少遍,它还是偶然发生的。因为再多次的偶然累计在一起也不可能把偶然变成必然。实际上,我们生活中常常遇到类似不靠谱的结论。比如因为“少年犯中80%的人都玩网络游戏”,就得出结论,说“玩网络游戏会导致青少年犯罪”。那“100%的少年犯每天都吃饭”该怎么解释?休谟有一句名言,说你怎么知道明天的太阳会照样升起。对休谟不屑一顾的人,把这句话当作休谟白日做梦的笑话。而对于被休谟说服了的人,这句话代表的是休谟结论的可怕结果。包括康德,以及后面的谢林、黑格尔、费尔巴哈、叔本华、尼采、马克思、胡塞尔、海德格尔,还有对哲学影响颇大的爱因斯坦、海森堡。这个超豪华阵容全部都是德意志人。他们中有不少是犹太人。康德却是个另类。在他漫长的一生中,只短暂离开过家乡的小镇一两次,最远只到过100公里外的地方。他几乎一辈子都蜗居在自己家里,而且终身未婚。其实康德有两次求婚的机会,但全都因为他的优柔寡断,结果错失良机——完全就是宅男的典范呀!话说康德看了休谟的论述之后,很震撼。他觉得休谟说得没错,理性主义属于独断论,经验主义又不能证明事物之间存在因果关系。康德为此想了很久,突然,一个大胆到狂妄的念头产生了。这个比喻说,假设每个人终身都必须戴着一副蓝色的有色眼镜。这个世界上所有的事物,必须都通过有色眼镜的过滤才能被人看到。那么所有人看到的就是一个蓝色的世界,而世界真实的面貌是人永远看不到的。 在这个比喻里,有色眼镜是先天认识形式,事物原本的颜色是物自体,人类看到的蓝色的世界,是表象。康德的解决方法是,他把世界分成了两个部分。一个部分完全不可知,另一个部分则可以用理性把握。不可知的那部分因为永远不可知,所以对我们的生活没有什么影响。只要我们在可把握的世界里生活,理性就又恢复了威力。就像康德的名言:“有两种东西,我对它们的思考越是深沉和持久,它们在我心灵中唤起的惊奇和敬畏就会日新月异,不断增长。这就是我头上的星空和心中的道德定律。”康德的作息时间严格得出了名,但据说有一件事曾经让他主动打乱了自己的作息时间表:读卢梭的《爱弥儿》。他屋里挂着的唯一一幅画就是卢梭的画像。康德非常喜欢卢梭,而且还关注了在卢梭的影响下那个彻底改变世界历史的大事件:法国大革命。我们今天对辩证法有一种庸俗的理解,说辩证法就是“看待事物要分两个方面”。别人批评一个现象,你非要说“要辩证地看这件事,这件事也有好的一面嘛”。这是对辩证法的极大误读。这不叫辩证法,这叫诡辩法,它的唯一作用是把所有的事实都捣成一片糨糊,逃避一切有意义的结论。他认为,世界不是容不得矛盾的,而恰恰相反,到处都是矛盾,矛盾就是世界的本质。黑格尔认为,矛盾的双方可以共存,但是处在互为差异、甚至互相冲突的动态之中。事物的正题和反题会发生强烈的冲突,这个冲突的结果并不是一方消灭另一方,而是正题和反题最终化为“合题”达到了协调,升华了。 前面说过,有一个正题就可以找到它的反题,因此新的合题产生之后,它的反题也随之产生,这样就又产生了新的矛盾,又要有新的冲突和升华,再产生新的合题因此黑格尔认为,事物是不断变化的,这种变化是自发的、抑制不住的。 同时,这种变化不是无序的,而是有方向的,这个方向就是较低级的正题和反题不断变成更高级的合题,也就是事物不断在向高级形态变化。换句话说,理性经过不断的辩证,就可以完全符合客观世界的真实面貌。理性就是世界的本质,世界的本质就是理性。 所以说,宇宙的本质是精神,而且是一种理性精神。 这个理性精神,就是黑格尔的“绝对精神”。因为重视历史过程,黑格尔是第一个重视研究哲学史的人。今天人们学西方哲学的时候,公认最好的办法是先读一本《西方哲学史》才有资格再谈别的,这个风气就是从黑格尔开始的。因此,黑格尔说:“凡是合乎理性的东西都是现实的,凡是现实的东西都是合乎理性的。”按照我的理解,这里的“理性”指的是绝对精神。“现实”指的是符合历史必然性的事物。这句话的意思是,所有合乎绝对精神的事物,必然会发生。我们知道,黑格尔的历史观后来被马克思批判性地继承,变成了辩证唯物主义历史观——马克思也认为,历史的进程是有方向的,不可逆转、不可阻止的,但是可以预测的。黑格尔是形而上学的巅峰,他创造了一个史上最完备、最庞大的形而上学世界。黑格尔在生前就获得了巨大的声望。在他50岁的时候,黑格尔正在柏林大学当教授。不久以后,他将会出任柏林大学的校长,他的学说将被钦定为国家的官方学说。生命意志的概念比一般的生物欲望还要宽泛,还包括没有生命的事物在内。叔本华认为,宇宙中万事万物背后都有生命意志在驱动。小到磁石相吸,大到星球运行,背后的本质原因都是生命意志。意志是个充满欲望的君王,但是它头脑糊涂,只知道发布命令,不知道该怎么去更好地达到目的。理性是个头脑清醒的老臣,它虽然对君王的命令有意见,但是限于身份,只能偶尔劝谏君王,大部分时候都是在用它的聪明才智去满足君王的欲望。 理性不是没有用,只是实现意志的工具而已。而叔本华说,生命意志是邪恶的,是痛苦的源泉。所以每个人都逃脱不了痛苦。 叔本华为什么这么说呢? 满足欲望会带来快乐,这没错。但是叔本华认为,欲望本质上是痛苦之源。 因为满足不了欲望,人会痛苦。满足了欲望,人又会产生新的、更高的欲望,还是会痛苦。 叔本华打比方说,满足欲望,就好比施舍给乞丐一个硬币,维持他活过今天,以便把他的痛苦延续到明天。叔本华还引用一句法国谚语,说明人们无止境的欲望:“更好是好的敌人。”所以快乐只是暂时的,痛苦才是永恒的。人生就好像在痛苦和无聊之间不停摆动的钟摆。这种情景就像王尔德说的:“人生有两大悲剧:一个是得不到想要的东西,另一个是得到了。”欲望除了能给人类带来无尽的痛苦,还有一个坏处,会带来自私和竞争。生命意志就是不顾一切也要自身生存着的意志。在生命意志的驱使下,每一个生物都为了自己的利益去争去抢。人和人之间会因此互相伤害。物种间也是这样,比如一个物种吃另一个物种。首先,叔本华的悲观主义从某些角度上看确实是成立的。虽然说理性未必就会败给欲望,但对于大部分人来说,欲望的确是生活的主题。我们是为了获得尽可能多的安全感,为了有更好的物质享乐,为了和别人攀比,才会去忍受无穷无尽的艰辛劳动和在各种挫折中的垂头丧气。大部分人这一辈子活着,为的都是满足各种各样的欲望。我们也同意,欲望是永远不会被满足的。满足了就会产生新的欲望,不满足就会产生饥渴感。对于哲学史来说,叔本华最大的价值不在于悲观主义的世界观,而在于他暗示了一个巨大的危机。 理性没落的危机。所以,人类固然有艺术这类非理性的成就,但是没有了理性,人类就不能积累知识,不能劳动生产,不会谋生,甚至于连自己是谁都不知道了,如同行尸走肉。叔本华,一般人以为他是一个悲天悯人的慈祥老头。不!生活中他暴躁刻薄。 尼采,一般人以为他是一个放荡不羁的狂人——不,生活中他是一个温和的智者。尼采继承了叔本华的形而上学。叔本华说物自体是“生命意志”,尼采给改造成了“权力意志”。 “权力意志”一词中的“权力”容易引起误解。这并不是政治权力的意思,而是指要让自己变得更强大、更强壮、更富创造力的欲望。他谈的第一种道德是属于弱者的道德,尼采叫它奴隶道德(又叫“畜群道德”)。 表面的内容是同情、仁慈、谦卑、平等。其实本质上,是弱者为了掩盖自己对强者的恐惧、嫉妒和自私,借助奴隶道德去限制强者。实际上我们细想,这个所谓的“奴隶道德”,不就是我们人类社会的传统道德吗?所以尼采说:“迄今为止用来使人变得道德的一切手段都是不道德的。”尼采说的第二种道德是强者的道德,它可以叫作贵族道德。这种道德鼓励人们积极进取,特立独行,崇尚强大,鄙视软弱,追求创新,拒绝平庸,它代表了生命积极的一面。尼采认为,奴隶道德和贵族道德最明显的区别在于:奴隶道德总是在禁止,不许人们做这做那;贵族道德则是在鼓励人们自由创造。这是因为,权力意志是物自体,是一切事物的本质,自然也是弱者的本质。因此弱者本性也像强者那样,希望能彰显自己的意志,驾驭弱者。但是弱者他自己弱啊,没能力啊,因此弱者只能躲在“奴隶道德”下,掩盖自己残忍的本质。弱者是虚伪的,而强者的残忍是彰显自己的本性,是正当的。“超人”这个词在尼采的理论里不是指拥有强大权力的人,不是说这人一定要当总统、当将军,而是指能够完全按照自己的意志行动、能充分发挥自己的创造力,并且能摆脱奴隶道德、不被弱者束缚的强者。超人是尼采对人类的一种理想,在尼采眼里,整个人类历史里也很少有人能成为真正的超人。进化论把这神秘性给打破了。进化论就像牛顿力学那样,用极为简单的理论解释了复杂的世界,而且逻辑严谨,能自圆其说,不需要任何超自然力量的干涉,比牛顿力学更容易让人接受。这幅圆形图的意思是说,不管生物的构造是否复杂,大家都是演化的幸存者。简单地说,社会达尔文主义的意思是,我们的社会也应该像优胜劣汰的大自然那样,有很高的淘汰率,把不适合生存的人都淘汰掉,以便达到最高效的进化。其中最具代表性的就是纳粹的种族主义。纳粹认为只有“优等”种族才有权利在资源有限的地球上生存下去,其他的“劣等”种族必须淘汰掉,以免和优等种族抢夺资源,以免他们以通婚方式“污染”优等种族的基因。这种社会达尔文主义给纳粹迫害犹太人找到了理论借口。在古代,人类以为地球是宇宙的中心,日心说打破了这个美梦,告诉我们人类不过是生活在广大银河系一隅中、微不足道的星系里、一个微不足道的小星球上的一种生物,没有任何特殊的地位。人类原本还以为自己是万物之首,和其他动物相比有着截然不同的高贵地位,所以在基督教里,只有人类才有灵魂。 然而进化论把这种自满也给消灭了。人类只不过是为了生存、在进化论规律下随机突变出的一种生物而已。在进化的过程中,人类也没有什么高贵性、神圣性。就不说他3岁指出父亲账本的错误,不说他22岁获得博士学位,也不说他25岁当选院士,更不说他精通六七种语言。 只说他19岁的时候就想出了正十七边形的尺规画法。在他之前的所有大数学家,包括牛顿在内,都没能想出这方法来。当然,我知道,您大概跟我一样,对这什么什么边形没什么概念。正好网上可以搜到画这个正十七边形的动画,您自个儿看一下就能感受到了。我的意思是,别说19岁了,就算你我学到29岁,这画法咱都未必能学会。 这个人您大概猜出来了,他叫高斯,法国人,人送外号数学小王子广义相对论的意思是说,当空间中存在物质和能量的时候,空间就会受到影响而弯曲,质能越大,空间弯曲得越厉害。引力就是这种空间弯曲产生的。罗素高寿,活了98岁。他出生的时候是中国同治十一年,颐和园还没开始建造。他去世的时候是1970年,互联网已经诞生了。他的名言是:“三种单纯又极其强烈的激情支配着我的一生:对爱情的渴望,对知识的追求,以及对于人类苦难不可遏制的同情。”这话广为流传。一个是,毛姆小说《刀锋》主角的原型就是维特根斯坦,两者在经历上有很多呼应的地方。具体来说:科学理论必须能提出一个可供证伪的事实,假如这个事实一经验证,便承认该理论是错的。换句话说,所有的科学理论都是一种假说,科学家没有办法证实任何一种科学理论。但是科学理论可以给别人提供验错的机会。在没被检验出错误之前,我们就姑且相信这个科学理论是正确的。证伪主义的科学观是,人类提出的各种科学理论有点像是基因突变,科学家们发散思维,想出各种充满想象力的假说。证伪就如同自然环境对基因的筛选,经不住证伪的假说都被淘汰,留下的都是经得住检验的,也就是暂时正确的科学理论。 那些留下来的理论,科学家们也在不断地尝试证伪,一旦证明是错的,就进行修改。这样科学理论就会越来越完善。这个试错、修改、完善的过程是无休止的,科学也因此会越来越接近真理。概率主义认为,我们每一次检验科学理论正确,都是在为科学作贡献。证伪主义认为,检验正确并不为科学作贡献,只有检验出科学理论是错的,才是真正为科学作贡献。证伪主义的政治观,最关心的不是谁制定的政策,而是无论谁制定的政策,都不能成为绝对真理。不管是美国总统下的命令还是全世界人民投票的结果,都要给别人留出修改、推翻它的机会。可以随时“纠错”而不是“多数说了算”,这才是现代民主制度的核心精神。科学就是建立在经验主义基础上的、以实用主义为原则筛选出来的、可以被证伪的理论。实际上,所有的形而上学都会陷入无法证明自身的困境。加缪说过:“真正严肃的哲学问题只有一个,那就是自杀。”","tags":[{"name":"笔记","slug":"笔记","permalink":"http://wuyang910217.github.io/tags/笔记/"},{"name":"文学","slug":"文学","permalink":"http://wuyang910217.github.io/tags/文学/"}]},{"title":"the alchemist摘录","date":"2016-11-13T13:34:47.000Z","path":"2016/11/13/the-alchemist.html","text":"简介The Alchemist 中文译名《牧羊少年奇幻之旅》，作者保罗·科尔贺（Paulo Coelho），wiki介绍Foreword前言When I sat down to write The Alchemist, all I knew is that I wanted to write about my soul. I wanted to write about my quest to find my treasure. I wanted to follow the omens, because I knew even then that the omens are the language of God.Prologue开场白The alchemist picked up a book that someone in the caravan(商队) had brought. Leafing through(翻阅) the pages, he found a story about Narcissus(水仙花).The alchemist knew the legend of Narcissus, a youth who knelt daily beside a lake to contemplate(注视，沉思) his own beauty. He was so fascinated by himself that, one morning, he fell into the lake and drowned(溺死). At the spot where he fell, a flower was born, which was called the narcissus.But this was not how the author of the book ended the story.He said that when Narcissus died, the goddesses of the forest appeared and found the lake, which had been fresh water, transformed into a lake of salty tears.“Why do you weep?” the goddesses asked.“I weep for Narcissus,” the lake replied.“Ah, it is no surprise that you weep for Narcissus,” they said, “for though we always pursued him in the forest, you alone could contemplate his beauty close at hand.”“But…was Narcissus beautiful?” the lake asked.“Who better than you to know that?” the goddesses said in wonder. “After all, it was by your banks that he knelt each day to contemplate himself!”The lake was silent for some time. Finally, is said:“I weep for Narcissus, but I never noticed that Narcissus was beautiful. I weep because, each time he knelt beside my banks, I could see, in the depths of his eyes, my own beauty reflected.”“What a lovely story,” the alchemist thought.Part oneDUSK was falling as the boy arrived with his herd(牲畜) at an abandoned church. The roof had fallen in long ago, and and enormous sycamore(圣经中的桑树) had grown on the spot where the sacristy(圣器室) had once stood.Thinking about that for a moment, the realized that it could be the other way around: that it was he who had become accustomed to their schedule.But ever since he had been a child, he had wanted to know the world, and this was much more important to him than knowing God and learning about man’s sins.The boy could see in his father’s gaze a desire to be able, himself, to travel The world–a desire that was still alive, despite his father’s having had to bury it, over dozens of years, under the burden of struggling for water to drink, foot to eat, and the same place to sleep every night of his life.It’s the possibility of having a dream come true that makes life interesting.And dreams are the language of God. When he speaks in our language, I can interpret what he has said. But if he speaks in the language of the soul, it is only you who can understand.A shepherd always takes his chances with wolves and with drought, and that’s what makes a shepherd’s life exciting.I only interpret dreams. I don’t know how to turn them into reality. That’s why I have to live off what my daughters provide me with.Everyone seems to have a clear idea of how other people should lead their lives, but none about his or her own.“What’s the world’s greatest lie?” the boy asked, completely surprised.It’s this: that at a certain point in our lives, we lose control of what’s happening to us, and our lives become controlled by fate. That’s the world’s greatest lie.Sometimes it’s better to be with the sheep, who don’t say anything. And better still to be alone with one’s books. They tell their incredible stories at the time when you want to hear them.Personal Legend(天命)At that point in their lives, everything is clear and everything is possible. They are not afraid to dream, and to yearn for everything they would like to see happen to them in their lives. But, as time passes, a mysterious force begins to convince them that it will be impossible for them to realize their Personal Legend.It’s a force that appears to be negative, but actually shows you how to realize your Personal Legend. It prepares your spirit and your will, because there is one great truth on this planet: whoever you are, or whatever it is that you do, when you really want something, it’s because that desire originated in the soul of the universe. It’s your mission on earth.When you want something, all the universe conspires in helping you to achieve it.If you start out by promising what you don’t even have yet, you’ll lose your desire to work toward getting it.Here I am, between my flock and my treasure, the boy thought. He had to choose between something he had become accustomed to and something he wanted to have.Because there is a force that wants you to realize your Personal Legend; it whets your appetite with a taste of success.In order to find the treasure, you will have to follow the omens. God has prepared a path for everyone to follow. You just have to read the omens that he left for you.The secret of happiness is to see all the marvels of the world, and never to forget the drops of oil on the spoon.I’m like everyone else － I see the world in terms of what I would like to see happen, not what actually does.If I can learn to understand this language without words, I can learn to understand the world.Part TwoYou and I aren’t like Hassan, that rich merchant. If he makes a buying mistake, it doesn’t affect him much. But we two have to live with our mistakes.We have to take advantage when luck is on our side, and do as much to help it as it’s doing to help us. It’s called the principle of favor-ability. Or beginner’s lucky.We are obliged, at least once in our lives, to visit the holy city of Mecca.Because it’s the thought of Mecca that keeps me alive. That’s what helps me face these days that are all the same, these mute crystals on the shelves, and lunch and dinner at that same horrible cafe. I’m afraid that if my dream is realized, I’ll have no reason to go on living.I have been told that beauty is the great seducer(诱惑者) of men.every blessing ignored becomes a curse. I don’t want anything else in life. But you are forcing me to look at wealth and at horizons I have never known.That there was a language in the world that everyone understood, a language the boy had used throughout the time that he was trying to improve things at the shop. It was the language of enthusiasm, of things accomplished with love and purpose, and as part of a search for something believed in and desired.When you want something, all the universe conspires to help you achieve it.He had worked for an entire year to make a dream come true, and that dream, minute by minute, was becoming less important. Maybe because that wasn’t really his dream.The Englishman was sitting on a bench(长凳) in a structure that smelled of animals, sweat, and dust; it was part warehouse(仓库), part corral(畜栏).Making a decision was only the beginning of things. When someone makes a decision, he is really diving into a strong current that will carry him to places he had never dreamed of when he first made the decision.the mysterious chain that links one thing to another, the same chain that had caused him to become a shepherd, that had caused him recurring dream, that had brought him to a city near Africa, to find a king, and to be robbed in order to meet a crystal merchant, and …Although the boy had developed a superstition that each time he opened the book he would learn something important, he decided it was an unnecessary burden.People need not fear the unknown if they are capable of achieving what they need and want.We are afraid of losing what we have, whether it’s our life or our possessions and property. But this fear evaporates when we understand that our life stories and the history of the world were written by the same hand.When you want something with all your heart, that’s when you are closest to the Soul of the World. It’s always a positive force.Because I don’t live in either my past or my future. I’m interested only in the present. If you can concentrate always on the present, you’ll be a happy man. You’ll see that there is life in the desert, that there are stars in the heavens, and that tribesmen fight because they are part of the human race. Life will be a party for you, a grand festival, because life is the moment we’re living right now.The closer he got to the realization of his dream, the more difficult things became. It seemed as if what the old king had called “beginner’s luck” were no longer functioning. In his pursuit of the dream, he was being constantly subjected to tests of his persistence and courage. So he could not be hasty, nor impatient. If he pushed forward impulsively, he would fail to see the signs and omens left by God along his path.At that moment, it seemed to him that time stood still, and the Soul of the World surged within him. When he looked into her dark eyes, and saw that her lips were poised between a laugh and silence, he learned the most important part of the language that all world spoke—- the language that everyone on earth was capable of understanding in their heart. It was love. Something older than humanity, more ancient than the desert. Something that exerted the same force whenever two pairs of eyes met, as had theirs here at the well. She smiled, and that was certainly an omen —- the omen he had been awaiting, without even knowing he was, for all his life.But maybe people who felt that way had never learned the universal language. Because, when you know that language, it’s easy to understand that someone in the world awaits you, whether it’s in the middle of the desert or in some great city. And when two such people encounter each other, and their eyes meet, the past and the future become unimportant. There is only that moment, and the incredible certainty that everything under the sun has been written by one hand only. It is the hand that evokes love, and creates a twin soul for every person in the world. Without such love, one’s dreams would have no meaning.I’m going to wait here for you every day. I have crossed the desert in search of a treasure that is somewhere near the Pyramids, and for me, the war seemed a curse. But now it’s a blessing, because it brought me to you.“If good thins are coming, they will be a pleasant surprise.” said the seer. “If bad things are, and you know in advance, you will suffer greatly before they even occur.”Courage is the quality most essential to understanding the Language of the World.“It’s not what enters men’s mouths that’s evil,” said the alchemist. “ It’s what comes out of their mouths that is.”Camels are traitorous(背信弃义的): they walk thousands of paces and never seem to tire. Then suddenly, they kneel and die. But horses tire bit by bit. You always know how much you can ask of them, and when it is that they are about to die.From that day on, it was the desert that would be important. She would look to it every day, and would try to guess which star the boy was following in search of his treasure. She would have to send her kisses on the wind, hoping that the wind would touch the boy’s face, and would tell him that she was alive. That she was waiting for him, a woman awaiting a courageous man in search of his treasure. From that day on, the desert would represent only one thing to her: the hope for his return.It’s because I’m the heart of a person, and people’s hearts are that way. People are afraid to pursue their most important dreams, because they feel that they don’t deserve them, or that they’ll be unable to achieve them. We, their hearts, become fearful just thinking of loved ones who go away forever, or of moment that could have been good but weren’t, or of treasures that might have been found but were forever hidden in the sands. Because, when these things happen, we suffer terribly.Tell your heart that the fear of suffering is worse than the suffering itself.Every search begins with beginner’s luck. And every search ends with the victor’s being severely(严厉地) tested.It said that the darkest hour of the night came just before the dawn.When you possess great treasures within you, and try to tell others of them, seldom are you believed.Men have never understood the words of the wise. So gold, instead of being seen as a symbol of evolution, became the basic for conflict.If a person is living out his Personal Legend, he knows everything he needs to know. There is only one thing that makes a dream impossible to achieve: the fear of failure.Usually the threat of death makes people a lot more aware of their lives.Everything that happens once can never happen again. But everything that happens twice will surely happen a third time.But here he was ,at the point of finding his treasure, and he reminded himself that no project is completed until its objective has been achieved. The boy looked at the sands around him, and saw that, where his tears had fallen, a scarab beetle was scuttling through the sand. During his time in the desert, he had learned that, in Egypt, the scarab beetles are a symbol of God.Epilogue(尾声，后记)Life really is generous to those who pursue their Personal Legend.An inspirational companion to The Alchemist that invites us to live out our dreams, to embrace the uncertainly of life, and to rise to meet our own unique destiny.","tags":[{"name":"笔记","slug":"笔记","permalink":"http://wuyang910217.github.io/tags/笔记/"},{"name":"英语","slug":"英语","permalink":"http://wuyang910217.github.io/tags/英语/"}]},{"title":"使用meteor/react过程中的一些代码片段","date":"2016-11-12T08:31:40.000Z","path":"2016/11/12/meteor-react-code-snippets.html","text":"简介这里是我学习meteor,react及其相关技术的一些代码片段和总结，持续更新．．．arrow function箭头函数的使用方法：使用大括号，里面必须有return语句使用括号，里面不用return关键字，易读不使用括号，适用于返回一条语句，不易读12345678910111213Meteor.publish('posts.all', function() &#123; return Posts.find(&#123;&#125;);&#125;);//betterMeteor.publish('posts.all', () =&gt; &#123; return Posts.find(&#123;&#125;);&#125;);//bestMeteor.publish('posts.all', () =&gt; ( Posts.find(&#123;&#125;)));//fineMeteor.publish('posts.all', () =&gt; Posts.find(&#123;&#125;) );mongo数据库链式操作数据库结构：title —&gt;stringcontents —&gt;arrayname —&gt;stringread —&gt;boolean…createdAt —&gt; date…需要传递的参数：title —&gt;stringcontentName —&gt; stringread —&gt;boolean以下表示：找出标题为title,且内容的名字叫contentName的文章,并把它的内容中的已读值设置为read1234Posts.update( &#123; title: title, 'contents.name': contentName &#125;, &#123; $set: &#123; 'contents.$.read': read &#125; &#125;);react dangerouslySetInnerHTML注意大括号，接受object1&lt;div dangerouslySetInnerHTML=&#123;&#123; __html: content &#125;&#125;&gt;react组件生命周期函数上传并显示图片时，如果离开页面，然后再次返回，还会显示上次上传的图片，需要调用react的生命周期函数．123456789101112131415componentWillMount() &#123;//在这里不起作用 const &#123;dispatch, addCover&#125; = this.props; dispatch(addCover(''));&#125;,componentWillUnmount() &#123;//需要在组件卸载前，清空一下图片地址 const &#123;dispatch, addCover&#125; = this.props; dispatch(addCover(''));&#125;,componentDidMount() &#123;//在这里传入上传后的图片地址 const &#123;dispatch, addCover&#125; = this.props; dispatch(addCover(url));&#125;summernote编辑器显示内容让编辑器初始化时就显示传入的一些内容，比如一个html中的section内容1234567891011//最外层包裹编辑器，并通过dangerouslySetInnerHTML渲染html内容&lt;div className='editor'&gt; &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: section.content &#125;&#125;&gt;&lt;/div&gt;&lt;/div&gt;//初始化，这样section中的内容就会在编辑器中渲染出来componentDidMount() &#123; $('.editor').summernote(&#123; height: 250 &#125;);&#125;summernote编辑器的api调用假如我们希望点击显示或隐藏按钮后，编辑器能够动态显示，而不刷新整个页面，需要如下操作123456789101112131415161718192021222324252627282930//进入页面后，初始化编辑器componentDidMount() &#123; $('.editor').summernote(&#123; height: 250 &#125;);&#125;//组件有更新，只需调用summernote的reset api即可实现componentDidUpdate() &#123; $('.editor').summernote('reset');&#125;//一个页面有多个编辑器，需要调用以下的生命周期函数和编辑器的api//进入页面后，初始化编辑器componentDidMount() &#123; $('.editor').summernote(&#123; height: 250 &#125;);&#125;,//在这里删除componentWillUpdate() &#123; $('editor').each( () =&gt; $(this).summernote('destroy') );&#125;,//再次初始化componentDidUpdate() &#123; $('.editor').summernote(&#123; height: 250 &#125;);&#125;lodash中sortBy进行数组排序比如一篇文章有很多评论，需要根据评论数目进行排序，我们可以直接返回排序过的数组．12const singlePost = Posts.findOne();const sortedComments = _.sortBy(singlePost.comments, ['count']);","tags":[{"name":"meteor","slug":"meteor","permalink":"http://wuyang910217.github.io/tags/meteor/"},{"name":"react","slug":"react","permalink":"http://wuyang910217.github.io/tags/react/"}]},{"title":"kindle中导出笔记","date":"2016-11-10T11:19:30.000Z","path":"2016/11/10/kindle-notes-export.html","text":"简介用过kindle的朋友会知道，我们标注后的内容会存在设备目录下的documents/My Clippings.txt文件中，里面内容很多，阅读起来很乱，更别说再次整理了．所以有了clippings.io等工具，让我们可以方便地管理标注的内容，并导出为pdf等常见格式．但操作起来流程很多，需要先让kindle连上电脑，取出其中的My Clippings.txt文件，并上传到 clippings.io 网站上，然后网站会自动读取其中的内容，并生成全部的内容．网站很强大，但却不是我想要的，我不想要全部的内容，而是读完一部小说或作品后，就可以导出标注的内容．没想到，kindle已经实现了这个功能，不知是最近更新后的功能，还是以前没有在意，总之非常方便和实用．步骤在我们阅读的作品中，点击屏幕左上角，有一个前往按钮，点击按钮，有作品的目录和标注的笔记，点击笔记，在最下面有一个导出笔记按钮，点击后，kindle就会发送你的笔记和标注内容到你的注册邮箱中，其中有pdf和excel格式的文件．下载后保存即可．另外，亚马逊生成的pdf文件格式很好看，如下图：kindle","tags":[{"name":"kindle","slug":"kindle","permalink":"http://wuyang910217.github.io/tags/kindle/"}]},{"title":"react学习--增强型组件","date":"2016-09-15T14:42:58.000Z","path":"2016/09/15/react-enhanced-component-demo.html","text":"简介很多react相关的包都有这样的语法export default SomeComponent(App);,我们自己也可以创建，以下是一个小demo．It’s no longer possible to use React mixin mechanism for components written in ES6.参考网站：react-and-es6Timer.js12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react';export const TimerEnhance = Compose =&gt; class Timer extends React.Component &#123; //es7语法 //显示在react developer tools中，位于顶部，不写为默认的Timer static displayName = 'ComponentEnhancedWithIntervalHOC'; // 默认值 测试 static defaultProps = &#123; name: 'test', number: 3&#125;; constructor(props) &#123; super(props); this.state=&#123;seconds: 0&#125;; &#125; componentDidMount() &#123; this.interval = setInterval(this.tick.bind(this), 1000); &#125; componentWillUnmount() &#123; clearInterval(this.interval); &#125; tick() &#123; this.setState(&#123; seconds: this.state.seconds + 1000 &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;Compose &#123;...this.state&#125; &#123;...this.props&#125;/&gt; &lt;h1&gt;TimerEnhance&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;App.js12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; TimerEnhance &#125; from './Timer';// es7语法 // @TimerEnhanceclass App extends Component &#123; //es7语法 默认state state = &#123;value: ''&#125;; handleClick = (e) =&gt; &#123; this.setState(&#123;value: this.state.value+'new'&#125;); &#125; render() &#123; // TimerEnhance中的state,props都会转化为props，并且在App组件中，可以直接调用，如this.props.seconds console.log(this.props,this.state); return ( &lt;div&gt; &lt;h1&gt;Test: &#123;this.props.seconds&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleClick&#125; &gt;Click &#123;this.state.value&#125;&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default TimerEnhance(App);index.js1234import React from 'react';import ReactDOM from 'react-dom';import App from './App';ReactDOM.render(&lt;App /&gt;, document.querySelector('#root'));","tags":[{"name":"react","slug":"react","permalink":"http://wuyang910217.github.io/tags/react/"}]},{"title":"react学习－－官方文档中事件绑定的３中方法","date":"2016-09-08T14:42:58.000Z","path":"2016/09/08/react-bind-three-ways.html","text":"简介最近，react的官方文档有了一次更新，文档描述的更加易懂，其中介绍了事件绑定的３种不同的写法，这里做一下总结．３中写法,如今第一种最常见，在constructor中进行绑定第二种是es2016特性–property initializer syntax第三种是arrow function in the callback这篇文章介绍了更多的方法，可以参考完整实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// 第一种方法class TodoApp1 extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; items: [], text: '' &#125;; // 这里绑定 this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); // 还能简写 // this.handleChange = ::this.handleChange; // this.handleSubmit = ::this.handleSubmit; &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt; Todo &lt;/h3&gt; &lt;TodoList data=&#123;this.state.items&#125; /&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125; &gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;button&gt;Add #&#123;this.state.items.length+1&#125;&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125; handleChange(e) &#123; console.log('第一种方法----', this); this.setState( &#123;text: e.target.value&#125;); &#125; handleSubmit(e) &#123; e.preventDefault(); const newItem = &#123; text: this.state.text, id: Date.now(), &#125;; this.setState( (prevState) =&gt; (&#123; items: prevState.items.concat(newItem), text: '' &#125;)); &#125;&#125;// 第二种方法class TodoApp2 extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; items: [], text: '' &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt; Todo &lt;/h3&gt; &lt;TodoList data=&#123;this.state.items&#125; /&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125; &gt; &#123;/* 注意这里不加括号 */&#125; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;button&gt;Add #&#123;this.state.items.length+1&#125;&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125;// 属性初始化 handleChange = (e) =&gt; &#123; console.log('第二种方法----', this); this.setState( &#123;text: e.target.value&#125;); &#125; handleSubmit = (e) =&gt; &#123; e.preventDefault(); const newItem = &#123; text: this.state.text, id: Date.now(), &#125;; this.setState( (prevState) =&gt; (&#123; items: prevState.items.concat(newItem), text: '' &#125;)); &#125;&#125;// 第三种方法class TodoApp3 extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; items: [], text: '' &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt; Todo &lt;/h3&gt; &lt;TodoList data=&#123;this.state.items&#125; /&gt; &lt;form onSubmit=&#123;(e) =&gt; this.handleSubmit(e)&#125; &gt; &#123;/* 这里必须有括号 this.handleChange(e) */&#125; &lt;input onChange=&#123;(e) =&gt; this.handleChange(e)&#125; value=&#123;this.state.text&#125; /&gt; &lt;button&gt;Add #&#123;this.state.items.length+1&#125;&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125; handleChange(e) &#123; console.log('第三种方法----', this); this.setState( &#123;text: e.target.value&#125;); &#125; handleSubmit(e) &#123; e.preventDefault(); const newItem = &#123; text: this.state.text, id: Date.now(), &#125;; this.setState( (prevState) =&gt; (&#123; items: prevState.items.concat(newItem), text: '' &#125;)); &#125;&#125;class TodoList extends React.Component &#123; render() &#123; return ( &lt;ul&gt; &#123;this.props.data.map((item,index) =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &#123;index+1&#125;---&gt;&#123;item.text&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; ); &#125;&#125;class Todo extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;TodoApp1 /&gt; &lt;TodoApp2 /&gt; &lt;TodoApp3 /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Todo /&gt;, document.querySelector('#root'));","tags":[{"name":"react","slug":"react","permalink":"http://wuyang910217.github.io/tags/react/"},{"name":"events","slug":"events","permalink":"http://wuyang910217.github.io/tags/events/"}]},{"title":"flow-router加载react组件及React中props的验证类型","date":"2016-09-02T14:42:58.000Z","path":"2016/09/02/react-proptypes.html","text":"简介在flow-router中，需要配合使用react-mounter来加载react组件，官方文档中给出了两种写法，随着react的发展，有些可能会报错．第一种写法1234567891011121314const MainLayout = (&#123;content&#125;) =&gt; ( &lt;div&gt; &lt;header&gt; This is our header &lt;/header&gt; &lt;main&gt; &#123;content()&#125; &lt;/main&gt; &lt;/div&gt;);mount(MainLayout, &#123; content: () =&gt; (&lt;WelcomeComponent name=&quot;Arunoda&quot; /&gt;)&#125;);现在需要使用如下格式,特别是this.props.content()，不然会报错：1234567891011121314151617181920export default class AppLayout extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header /&gt; &#123;this.props.content()&#125; &lt;Footer /&gt; &lt;/div&gt; ); &#125;&#125;AppLayout.propTypes = &#123; content: PropTypes.func.isRequired,&#125;;//在路由文件中，调用mount(AppLayout, &#123; content: () =&gt; (&lt;Welcome /&gt;), &#125;);注意，它的类型为PropTypes.func,是个函数，其他类型会报错；另一种写法1234567891011121314151617181920export default class AppLayout extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header /&gt; &#123;this.props.content&#125; &lt;Footer /&gt; &lt;/div&gt; ); &#125;&#125;AppLayout.propTypes = &#123; content: PropTypes.element.isRequired,&#125;;//在路由文件中，调用mount(AppLayout, &#123; content: &lt;Welcome /&gt;, &#125;);注意，这里它的类型为PropTypes.element；所有PropTypes类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 基本类型，默认可传可不传React.PropTypes.arrayReact.PropTypes.boolReact.PropTypes.funcReact.PropTypes.numberReact.PropTypes.objectReact.PropTypes.string// 所有可以被渲染的对象：数字，字符串，DOM 元素或包含这些类型的数组React.PropTypes.node//react元素React.PropTypes.element // 用 JS 的 instanceof 操作符声明 prop 为类的实例。 optionalMessage: React.PropTypes.instanceOf(Message), // 用 enum 来限制 prop 只接受指定的值。 optionalEnum: React.PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]), // 指定的多个对象类型中的一个 optionalUnion: React.PropTypes.oneOfType([ React.PropTypes.string, React.PropTypes.number, React.PropTypes.instanceOf(Message) ]), // 指定类型组成的数组 optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number), // 指定类型的属性构成的对象 optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number), // 特定形状参数的对象 optionalObjectWithShape: React.PropTypes.shape(&#123; color: React.PropTypes.string, fontSize: React.PropTypes.number &#125;), // 以后任意类型加上 `isRequired` 来使 prop 不可空。 requiredFunc: React.PropTypes.func.isRequired, // 不可空的任意类型 requiredAny: React.PropTypes.any.isRequired, // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接 // 使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error(&apos;Validation failed!&apos;); &#125; &#125;","tags":[{"name":"flow-router","slug":"flow-router","permalink":"http://wuyang910217.github.io/tags/flow-router/"},{"name":"react","slug":"react","permalink":"http://wuyang910217.github.io/tags/react/"}]},{"title":"flow-router中404页面---page not found的处理","date":"2016-08-22T14:42:58.000Z","path":"2016/08/22/meteor-flowrouter-data-not-found.html","text":"简介一般网站的404页面包括两种类型：1.路由匹配失败，没有此路由；2.路由匹配成功，但参数不对，没有数据显示。对于第一种情况，flow-router和iron-router都能轻松的处理，但对于第二种情况，iron-router可以设置dataNotFound的hook，而flow-router文档中并没有提及。本文就是对这种情况的总结。场景还原例如，在imports/startup/routes.js中，我定义了下面的路由，用于显示某个内容的详细信息：123456FlowRouter.route('/detail/:queryId',&#123; name: 'detail', action: function()&#123; BlazeLayout.render('mainLayout', &#123;main: 'detail'&#125;); &#125;&#125;);其中参数:queryId对应于Mongo数据库中的_id字段，当_id不存在时，我需要显示404页面，而不再渲染此页面的detail模板。其中BlazeLayout需要添加kadira:blaze-layout包：1234#终端执行meteor add kadira:blaze-layout#在路由文件中引入import &#123; BlazeLayout &#125; from &apos;meteor/kadira:blaze-layout&apos;;具体用法请看文档第一次尝试为了检查:queryId是否存在，我想到了flow-router中的triggersEnter方法，当执行此路由时，先检查数据是否存在，如果不存在，就直接渲染notFound，并且停止路由中action方法的执行，如下所示：12345678910111213141516171819FlowRouter.route('/detail/:queryId',&#123; name: 'detail', triggersEnter: [notExist], action: function()&#123; BlazeLayout.render('mainLayout', &#123;main: 'detail'&#125;); &#125;&#125;);#定义notExist函数function notExist(context,redirect,stop)&#123; let id = context.params.queryId; console.log(id); let detailContent = Resources.findOne(&#123;_id: id&#125;) || &#123;&#125;; console.log(detailContent.fetch()); if (isEmpty(detailContent)) &#123; BlazeLayout.render('notFound'); stop(); &#125;&#125;其中notExist函数共有3个参数，context必须，redirect可以没有，stop此方法必须。从context中，我们可以得到其id，然后通过查询数据库，检查返回的数据是否为空，如果为空，就执行BlazeLayout.render(&#39;notFound&#39;);，并且停止路由的下一步进行。其中isEmpty来源于lodash库：1234#终端执行meteor npm i -S lodash#路由文件中引入import &#123; isEmpty &#125; from &apos;lodash/lang&apos;;分析结果看起来逻辑没有错误，但是运行起来发现，当刷新页面时，就会显示404，而且浏览器终端也出现错误，通过console.log()对数据返回值的检查，发现Resources.findOne({_id: id})一直返回空对象，表示在route中数据库不起作用。第二次尝试在路由中没有成功，我准备在模板imports/ui/template/detail.js中再次尝试，如下：12345678910111213141516171819202122#在onCreated方法中订阅Template.detail.onCreated(function() &#123; let self = this; self.content = new ReactiveDict(); let queryId = FlowRouter.getParam('queryId'); self.subscribe('detail', queryId);&#125;);#在helpers中定义detail方法Template.detail.helpers(&#123; detail() &#123; let id = FlowRouter.getParam('queryId'); let detailContent = Resources.findOne(&#123; _id: id &#125;) || &#123;&#125;; if (isEmpty(detailContent)) &#123; FlowRouter.go('/404'); &#125; else&#123; let instance = Template.instance(); instance.content.set('content-detail', detailContent); console.log(detailContent,detailContent.contents.mimeType); return detailContent; &#125; &#125;&#125;）通过FlowRouter.getParam得到id，然后数据库查找，如果数据库为空，显示404页面；如果不为空，储存返回值detailContent到ReactiveDict中，用于在模板中获取内容。没想到，这次成功了，看来在路由文件声明中，不能使用数据库的查找。小的改进上面代码中，我使用了FlowRouter.go(&#39;/404&#39;)，这样就必须定义一个新的路由，没有必要，并且，浏览器地址栏就会变成如www.example.com/404；而如果使用BlazeLayout.render(&#39;notFound&#39;)，浏览器地址不会改变，如www.example.com/detail/ddddddd。可以直接改为：123if (isEmpty(detailContent)) &#123; BlazeLayout.render('notFound');&#125; else &#123;...&#125;但是有一个问题，刷新页面时，会闪过mainLayout布局文件的内容，如navbar，需要继续改进：123if (isEmpty(detailContent)) &#123; BlazeLayout.render('mainLayout', &#123;main: 'dataNotFound'&#125;);&#125; else &#123;...&#125;这里，我新建了一个模板文件dataNotFound，因为notFound模板样式与mainLayout的样式不一定兼容，最好是分开。这样，对于文章开头的两种情况：notFound 对应于第一种，显示全局的404页面dataNotFound 对应于第二种，显示数据没有找到的404页面小的问题在Template.detail.helpers()中，不止一个helper，比如我还定义了isImage方法，用于检查类型是否为图片：123isImage(type) &#123; return type.indexOf('image/') &gt; -1;&#125;但是在浏览器终端，就会出现这样的错误信息：error原因出在哪，不清楚，但使用lodash中的startsWith方法替代后，错误信息就没了。123456#首先引入import &#123; startsWith &#125; from &apos;lodash/string&apos;;#修改为isImage(type) &#123; return startsWith(type, &apos;image/&apos;);&#125;最后说明Meteor版本： 1.4.1.1Flow-router版本： 2.12.1Meteor从1.3版本开始，就能使用npm包了，并且项目结构有所改变，比如在detail.js文件开头，使用ES6语法来引入可能需要的包：123456789101112#使用meteor add添加的包import &#123; Meteor &#125; from &apos;meteor/meteor&apos;;import &#123; FlowRouter &#125; from &apos;meteor/kadira:flow-router&apos;;import &#123; Template &#125; from &apos;meteor/templating&apos;;import &#123; ReactiveDict &#125; from &apos;meteor/reactive-dict&apos;;import &#123; BlazeLayout &#125; from &apos;meteor/kadira:blaze-layout&apos;;#npm包import &#123; startsWith &#125; from &apos;lodash/string&apos;;import &#123; isEmpty &#125; from &apos;lodash/lang&apos;;# 项目文件import &#123; Resources &#125; from &apos;../../api/resources.js&apos;;import &apos;./detail.html&apos;;","tags":[{"name":"meteor","slug":"meteor","permalink":"http://wuyang910217.github.io/tags/meteor/"},{"name":"flow-router","slug":"flow-router","permalink":"http://wuyang910217.github.io/tags/flow-router/"}]},{"title":"flow-router中params的使用","date":"2016-08-20T11:19:30.000Z","path":"2016/08/20/flow-router-params.html","text":"简介最近学习了一下flow-router的使用，对于/detail/:queryId这样的路由如何传递参数做一下总结。场景还原例如，我们网站的主页面显示很多图片，而详情页显示每个具体图片的详细信息，在我们的routes.js文件中，可以这样定义两个路由：1234567891011121314151617// 主页面FlowRouter.route('/main',&#123; name: 'main', action: () =&gt; &#123; BlazeLayout.render('mainLayout', &#123;main: 'main'&#125;); &#125;, subscriptions: function()&#123; this.register('mainpage',Meteor.subscribe('contents')); &#125;,&#125;);// 详情页面FlowRouter.route('/detail/:queryId',&#123; name: 'detail', action: () =&gt; &#123; BlazeLayout.render('mainLayout', &#123;main: 'detail'&#125;); &#125;&#125;);注意，上面我们通过subscriptions方法订阅了所有内容的数据库，这是flow-router提供的方法，具体用法见文档：flow-router那么问题是如何得到每个:queryId，以及通过:queryId如何得到详细内容数据？params的定义首先在模板文件main.html中，定义两个模板：123456789&lt;template name='main'&gt; &#123;&#123;#each contents&#125;&#125; &#123;&#123;&gt; content&#125;&#125; &#123;&#123;/each&#125;&#125;&lt;/template&gt;&lt;template name='content'&gt; &lt;a href=\"&#123;&#123;pathForDetail&#125;&#125;\"&gt; &lt;img src=\"&#123;&#123;contents.url&#125;&#125;\" alt=\"&#123;&#123;contents.name&#125;&#125;\"&gt; &lt;/a&gt;&lt;/template&gt;这里我们显示所有的图片，且每张图片都是一个指向详情页的链接。更多Blaze模板系统的用法，请参考官方文档：Blaze然后我们要在main.js中定义一些helpers：123456789101112Template.main.helpers(&#123; contents() &#123; return Resources.find(&#123;&#125;, &#123;sort: &#123;createdAt: -1&#125;&#125;); &#125;&#125;);Template.content.helpers(&#123; pathForDetail() &#123; const params = &#123;queryId: this._id&#125;; return FlowRouter.path('detail', params); &#125;&#125;);重点就在这里，我们通过const params = {queryId: this._id};这一条语句获得每张图片的queryId，并保存在params里，然后通过FlowRouter.path()方法生成完整的路径url。这样我们点击任意一张图片，就能进入到与之对应的详情页面。注意：queryId要和路由中定义的参数名保持一致；我们可以定义任何的params，不局限于id。params的获得在publish.js中，我们定义了详情页的内容数据：123Meteor.publish(&apos;detail&apos;,(id) =&gt; &#123; return Resources.find(&#123;_id: id&#125;,&#123;fields: &#123;contents: 1&#125;&#125;);&#125;);然后在detail.js中，我们要subscirbe这一数据，那这个id如何获得呢，这就需要刚才我们储存在params里的值了：1234Template.detail.onCreated(function() &#123; const queryId = FlowRouter.getParam('queryId'); this.subscribe('detail', queryId);&#125;);只要我们需要图片的id，我们就可以从params里得到。接着我们还要定义helpers：123456Template.detail.helpers(&#123; detail() &#123; const id = FlowRouter.getParam('queryId'); return Resources.findOne(&#123; _id: id &#125;) || &#123;&#125;; &#125;&#125;);这样我们在模板中就可以通过detail这个helper，得到我们想要的任何数据。更近一步我们的detail方法还能改进，设想一下，我们需要在其他地方使用这个数据库的内容，比如其他的helper，或者events事件中，可是我们却没有地方获得。所以需要我们保存这个数据库的内容，代码可以改为：12345678910Template.detail.helpers(&#123; detail() &#123; const id = FlowRouter.getParam('queryId'); const detailContent = Resources.findOne(&#123; _id: id &#125;) || &#123;&#125;; const instance = Template.instance(); instance.content.set('content-detail', detailContent); console.log(instance.content.get('content-detail')); &#125;&#125;);我们把数据存到名字叫content的ReactiveDict中，这样我们在其他地方就能获取内容了,比如在events里：12const name = instance.get('content-detail').contents.name;const url = instance.get('content-detail').contents.url;注意,flow-router默认安装了这个包，我们只需要引入这个包，并且初始化：123456import &#123; ReactiveDict &#125; from &apos;meteor/reactive-dict&apos;;Template.detail.onCreated(function() &#123; this.content = new ReactiveDict(); ......&#125;);最后 一张图getData","tags":[{"name":"meteor","slug":"meteor","permalink":"http://wuyang910217.github.io/tags/meteor/"},{"name":"flow-router","slug":"flow-router","permalink":"http://wuyang910217.github.io/tags/flow-router/"}]},{"title":"Meteor中异步回调函数的错误处理","date":"2016-08-18T11:19:30.000Z","path":"2016/08/18/meteor-try-catch-handle-error.html","text":"简介七牛云 的内容管理默认没有文件的缩略图，如果我们想找某一张图片就会很头疼，所以我用Meteor做了一个小的demo，用来显示文件的缩略图，并有删除、移动、复制、下载等基本的操作功能。对于其中的错误处理，遇到了一些问题，在这里总结一下。demo图片：qiniu-manager服务器端异步回调函数在Meteor中，我们不能直接在Meteor.method()方法里调用异步函数，会报错，根据提示信息，我们可以用Meteor.bindEnvironment(function(err, ret){}这样的方式来绑定异步函数，不过在Atmospherejs上，已经有现成的包来提供更优雅的方式，就是meteorhacks:async。例如在imports/api/method.js中，对于下面的代码：123456789101112'resources.remove' (id, bucket, key) &#123; const client = new qiniu.rs.Client(); client.remove(bucket, key, Meteor.bindEnvironment(function(err, ret) &#123; if (!err) &#123; console.log('Meteor method resources.remove success'); Resources.remove(&#123; _id: id &#125;); &#125; else &#123; console.log('Meteor method resources.remove----&gt;'); console.log(err); &#125; &#125;));&#125;,我们可以改写成：1234567'resources.remove' (id, bucket, key) &#123; const client = new qiniu.rs.Client(); let wrapQiniuClient = Async.wrap(client, ['remove','stat','move','copy']); wrapQiniuClient.remove(bucket, key); console.log('Meteor method resources.remove success'); Resources.remove(&#123; _id: id &#125;);&#125;错误处理对于第一种方式，由于包裹在client.remove()里，错误信息不能直接回传到客户端，导致浏览器中没有错误提示。于是想到新建一个Errors数据库，如果有错误，就存到数据库，并且客户端订阅后，可以得到错误信息。123456else &#123; console.log('Meteor method resources.remove----&gt;');// 在这里把错误信息存入数据库 Errors.insert(&#123;err: err.error,code: err.code&#125;); console.log(err);&#125;但是，有一些问题，比如在客户端执行Meteor.call(&#39;resources.remove&#39;)，我们不能判断是否调用成功，因为服务器端无法处理错误。这样我们就不能写逻辑：调用成功，返回到主页面，调用失败，显示错误信息。对于第二种方式，我一开始没有正确的理解，也没有找到正确的方法。后来想到可以用try/catch语法，就赶紧试了一下，于是代码变成了：12345678try &#123; wrapQiniuClient.remove(bucket, key); console.log('Meteor method resources.remove success'); Resources.remove(&#123; _id: id &#125;);&#125; catch (err) &#123; console.log(err); throw new Meteor.Error('removeError', err);&#125;注意，这里我们抛出错误，客户端是可以接收到的，我们的处理逻辑也通顺了，在imports/ui/template/detail.js中：12345678910Meteor.call('resources.remove', id, bucket, key, (err) =&gt; &#123; if (err) &#123; console.log('resources.remove----&gt;'); console.log(err.reason); instance.error.set('error', err.reason); &#125; else &#123; console.log('resources.remove success'); FlowRouter.go('/main'); &#125;&#125;);我们把错误信息存到ReactiveDict里，在helpers中取出来：12345678910Template.detail.helpers(&#123; error() &#123; const instance = Template.instance(); const error = instance.error.get('error'); if (!isEmpty(error)) &#123; $('.err').show(); $('.err').fadeOut(5000); return error; &#125;&#125;,模板文件里detail.html:1&lt;h3 class=&quot;err&quot;&gt;操作失败：&#123;&#123;error.error&#125;&#125; 错误码：&#123;&#123;error.code&#125;&#125;&lt;/h3&gt;这样，当有错误时，我们简单的用jquery来显示。小的问题尝试了几次之后，发现了一个问题，第一次的错误信息可以正常显示，而以后的错误信息不会再显示了，查找原因后发现，在调用Meteor.call()之前，我们要把ReactiveDict里的值设置为空,然后就能正常工作了：1instance.error.set('error', '');另外，我们也可以定义一个操作成功的提示信息，方法相同，这里就不在赘述了，不过注意这里也需要先设置为空，如：1instance.success.set('success', '');最后如果大家看的不是很明白，可以直接看源码，项目地址：qiniu-manager","tags":[{"name":"meteor","slug":"meteor","permalink":"http://wuyang910217.github.io/tags/meteor/"},{"name":"async","slug":"async","permalink":"http://wuyang910217.github.io/tags/async/"}]},{"title":"meteor创建项目的准备工作","date":"2016-08-16T14:42:58.000Z","path":"2016/08/16/meteor-react-init.html","text":"Nodejs的安装nodejs的安装一般比较流行的是用nvm版本管理工具，可以安装不同版本的nodejs，对于需要来回切换node版本的人来说，非常方便。但是有这样一个问题，由于它只是安装在用户目录下，而不是全局，有时当我们查看node版本时，会出现node未安装的提示。一般情况下，我们的node版本并不需要改变，所以可以全局安装，这里我选用NodeSource来安装node,只需要两条命令：123# Using Ubuntucurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs我当前安装的版本为v6.3.1。Meteor的安装Meteor的安装同样非常简单，只需要一条命令，然后等待系统自动安装即可：1curl https://install.meteor.com/ | sh安装完成后，我们就可以创建项目，这里是一些有用的命令：123456789meteor help #查看帮助meteor --version #查看当前版本meteor node --version #查看meteor使用的node版本meteor create projectName #创建一个项目meteor run #在本地启动项目meteor list #列出项目使用的meteor包meteor add packageName #添加一个包meteor mongo #进入mongo数据库，必须本地服务已经启动meteor build #打包meteor项目，用于部署到服务器上项目的创建使用以下命令，创建新的项目：1meteor create MeteorBlog初次创建项目，时间会有点长，因为其实Meteor非常庞大，查看一下meteor的大小：1du -sh .meteor #大约有1G，而且以后会越来越大创建完成后，进入其目录cd MeteorBlog，运行一下meteor run，在浏览器中打开本机3000端口，就能看到meteor默认的运行页面。删除默认UI模板blaze，安装reactMeteor默认的视图层模板是Blaze，我们不打算使用，所以删除：123meteor remove blaze-html-templates#删除后，页面将不能渲染，需要添加下面这个包meteor add static-htmlmeteor创建新项目会生成一个package.json文件，说明meteor本身也是一个Node项目，我们需要执行npm install，来安装meteor-node-stubs这个依赖包。需要说明的是使用npm install安装的node包都存放在node_modules目录下。然后安装react，参见meteor guide：1npm install --save react react-dom到此为止，项目的前期准备工作差不多做完了。","tags":[{"name":"meteor","slug":"meteor","permalink":"http://wuyang910217.github.io/tags/meteor/"},{"name":"react","slug":"react","permalink":"http://wuyang910217.github.io/tags/react/"}]},{"title":"Meteor中accounts-github包的使用介绍","date":"2016-08-12T11:19:30.000Z","path":"2016/08/12/meteor-github-login.html","text":"简介Meteor中自带强大的账户系统，并有丰富的第三方账户登录包如Github，Google，Twitter等，让我们可以专注于主要业务需求的实现。但是它提供的样式单一，并且默认数据库Meteor.users的格式已经确定，不利于后期的扩展。如果我们已经有自己的账户系统和用户数据库，可能需要统一数据库的格式。本文主要有以下两个方面：使用Meteor提供的默认包来实现Github账户登录这个功能；自己配置，并把格式化的用户信息存入Meteor.users数据库中。Meteor默认账户系统介绍新建一个项目如github-login-demo：123456meteor create github-login-democd github-login-demo# 添加如下包meteor add accounts-uimeteor add accounts-passwordmeteor add accounts-github现在我们已经有了基本的账户系统，在你的main.html文件的body标签中加入这一行：1&#123;&#123;&gt; loginButtons&#125;&#125;此时运行meteor命令，打开浏览器，就能看到一个登录按钮，如图所示，login-conf我们可以注册和登录用户，上面github登录的配置也很简单，只需按照提示，填入我们在Github OAuth申请的Client ID和Client Secret值。github-conf完成后，我们就可以让用户使用Github账号登录了。自己配置用户登录信息现在我们的页面只能显示用户名，并且数据库的内容是默认生成好的，没有头像，仓库数量等信息，接下来我们就自己配置用户的数据库，来保存我们想要的内容。首先添加第三方服务配置包：1meteor add service-configuration在html文件中，添加一个button1&lt;button id=&quot;login&quot;&gt;Github账户登录&lt;/button&gt;在server/github.js中，添加配置项。具体内容，见Github地址(文章末尾)，通过响应按钮的点击事件，调用client/main.js里的Meteor.loginWithGithub()这个函数，我们就能实现用户的登录。需要说明的是，我们是作为第三方登录账号集成到user数据库中，因此需要判断用户是否是使用第三方直接登录，还是注册新账号。如果不用第三方登录，我们这里直接返回（也可以添加其他内容）。如下：123if (!user.services.github) &#123; return user; &#125;在github.js文件中，我们添加了user.profile用来储存一些我们想要的信息，停止meteor，运行1234# 清除以前的数据库内容meteor reset# 重新运行meteor现在点击按钮登录后，就会显现登录用户的一些信息，如图：show默认的用户数据库格式是固定的，我们使用默认的账户系统再注册一个新用户，对比这两个用户的信息，可以看到都有_id,createdAt,services,resume字段（文档），而使用github账号的用户中还有profile字段，这正是我们储存我们想要的用户信息的地方。user-db我们的profile字段看起来内容不多，其实Github返回的json内容很丰富，下面是完整的返回内容：1234567891011121314151617181920212223242526272829303132&#123; &quot;login&quot;: &quot;wuyang910217&quot;, &quot;id&quot;: 2918044, &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/2918044?v=3&quot;, &quot;gravatar_id&quot;: &quot;&quot;, &quot;url&quot;: &quot;https://api.github.com/users/wuyang910217&quot;, &quot;html_url&quot;: &quot;https://github.com/wuyang910217&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/users/wuyang910217/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/users/wuyang910217/following&#123;/other_user&#125;&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/users/wuyang910217/gists&#123;/gist_id&#125;&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/users/wuyang910217/starred&#123;/owner&#125;&#123;/repo&#125;&quot;, &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/wuyang910217/subscriptions&quot;, &quot;organizations_url&quot;: &quot;https://api.github.com/users/wuyang910217/orgs&quot;, &quot;repos_url&quot;: &quot;https://api.github.com/users/wuyang910217/repos&quot;, &quot;events_url&quot;: &quot;https://api.github.com/users/wuyang910217/events&#123;/privacy&#125;&quot;, &quot;received_events_url&quot;: &quot;https://api.github.com/users/wuyang910217/received_events&quot;, &quot;type&quot;: &quot;User&quot;, &quot;site_admin&quot;: false, &quot;name&quot;: &quot;wuyang&quot;, &quot;company&quot;: null, &quot;blog&quot;: null, &quot;location&quot;: null, &quot;email&quot;: &quot;wuyang910217@gmail.com&quot;, &quot;hireable&quot;: true, &quot;bio&quot;: null, &quot;public_repos&quot;: 11, &quot;public_gists&quot;: 0, &quot;followers&quot;: 0, &quot;following&quot;: 4, &quot;created_at&quot;: &quot;2012-11-29T04:25:43Z&quot;, &quot;updated_at&quot;: &quot;2016-04-01T09:00:21Z&quot;&#125;请到这里查看所有代码： github-login-demo参考资料Meteor文档： loginWithGithub()，onCreateUser()Meteor guide : Accounts后记本文内容基于accounts-password这个包自带的Meteor.users数据库，并没有重新构建新的数据库格式。","tags":[{"name":"meteor","slug":"meteor","permalink":"http://wuyang910217.github.io/tags/meteor/"},{"name":"github","slug":"github","permalink":"http://wuyang910217.github.io/tags/github/"}]},{"title":"chrome浏览器下好用的插件","date":"2016-08-10T11:19:30.000Z","path":"2016/08/10/useful-chrome-plugins.html","text":"简介Chrome浏览器下好用的扩展程序非常多，在此给大家分享我目前安装的一些插件．这里只是给出了名字，只需到网上应用店搜索即可．基础类Adblock Plus免受广告的打扰 👍Yet another flags显示网站所在地区的小工具LastPass管理你的网站密码，从此不怕忘记你的账号和密码了 👍OneTab众多标签页没有看完，下次还能接着看 👍Currently把New Tab替换成漂亮的样式，可以显示时间和天气 👍TransIt在线取词翻译 👍One-Click Extensions Manager装的插件有点多，浏览器变卡了，不用担心，一键管理所有的其他插件，随时启用和停止 👍BookMark Manager 管理你的标签Grammarly 检查你输入的文字的拼写和语法Short URL 短网址 👍Video Downloader Professional 提供视频下载Awesome screenshot 网页截图，提供简单修改功能，如添加文字和箭头，也可本地上传图片 👍Web开发Octotree在左侧显示github上项目的结构树 👍Wappalyzer显示网站所使用的技术，如框架，服务器，非常强大 👍ColorZilla别人网站的颜色好看？那不copy过来 👍JSON Viewer返回漂亮易读的json格式 👍DHC REST Client在浏览器中测试http请求 👍Alexa Traffic Rank查询网站的排名WhatFont显示网站上使用的字体的名称 👍React Developer Tools,Redux DevsTool开发工具 👍TypeWonder测试各种网站字体Responsive Web Design Tester提供响应式网站的测试 👍","tags":[{"name":"chrome","slug":"chrome","permalink":"http://wuyang910217.github.io/tags/chrome/"},{"name":"plugins","slug":"plugins","permalink":"http://wuyang910217.github.io/tags/plugins/"}]},{"title":"修改simple:highlight.js代码高亮的样式","date":"2016-08-08T11:19:30.000Z","path":"2016/08/08/add-local-meteor-package.html","text":"简介Meteor版本：1.2最近使用Meteor过程中，发现markdown包中的代码高亮几乎没有样式，于是在网上找了highlight.js这个代码高亮插件，下载的文件，分别放在client/lib/js和client/lib/css目录中，按网站介绍的配置后，没有效果，看来是不能很好的识别，只好到Atmospherejs搜索已经和Meteor集成好的包。发现了这个包simple-highlight.js，并且是和markdown集成好的，不用另外配置。1meteor add simple-highlight.js不过查看效果，并不是很好看，到它的Github项目主页浏览源码，发现它只有一种默认样式：github.css，就想到替换这个默认样式，在highlight.js官网找到了zenburn.css这个样式，最简单的方法就是直接替换css文件的内容，不过不太高大上，于是就需要我们修改它的包，制作成我们自己的包。修改源码包在项目主目录中，首先我们需要把源码下载到本地，并打开：123git clone https://github.com/stubailo/meteor-highlight.js.gitcd meteor-highlight.jssubl .修改package.js里面的内容：123456Package.describe(&#123; summary: &quot;Code highlighting integrated with the markdown package&quot;, version: &quot;1.2.0&quot;, name: &quot;simple:highlight.js&quot;, git: &quot;https://github.com/stubailo/meteor-highlight.js&quot;&#125;);主要是修改name，其他内容可以不变，例如我修改为：123456Package.describe(&#123; summary: &quot;modify---&gt;Code highlighting integrated with the markdown package&quot;, version: &quot;1.2.0&quot;, name: &quot;modify:simple:highlight.js&quot;, git: &quot;https://github.com/stubailo/meteor-highlight.js&quot;&#125;);在Package.onUse()中修改：123api.addFiles(&quot;github.css&quot;);#修改为api.addFiles(&quot;zenburn.css&quot;);然后只需要删除github.css文件，并添加zenburn.css文件。制作本地包在项目主目录中新建packages文件夹，注意Meteor的本地添加包都在这个文件夹下。把meteor-highlight.js这个文件夹添加进来：12mkdir packagesmv meteor-highlight.js packages/modify-highlight.js这里我把文件夹名称修改为modify-highlight.js，也可以不修改。然后运行以下命令，把本地包添加到项目中：1meteor add modify:simple:highlight.js注意这个包名就是name字段里的值。然后运行meteor list命令，就能看到我们的包已经添加进来，并且包名后面有个+号，说明是本地添加的包。更多你也可以在Atmospherejs上发布修改过的包，不过意义不是很大,毕竟我们只是修改了下css样式。","tags":[{"name":"highlight","slug":"highlight","permalink":"http://wuyang910217.github.io/tags/highlight/"},{"name":"meteor","slug":"meteor","permalink":"http://wuyang910217.github.io/tags/meteor/"}]},{"title":"超简单，利用Passenger部署Meteor到Ubuntu14.04服务器","date":"2016-08-06T11:19:30.000Z","path":"2016/08/06/deploy-meteor-app.html","text":"简介目前能够方便地部署Meteor app的方法还不多，一般都是用官网的Galaxy或者meteor up或者按照部署Nodejs服务器的方式。而如果我们想要使用Nginx作为Web服务器，其中配置的步骤又很繁琐，那有没有好的开源项目或者平台能够帮助我们减轻痛苦呢？答案是必须的。下面就隆重请出今天的主角——PhusionPassenger。Passenger简介passengerPassenger 想必对于Rails开发者都很熟悉了，使用Passenger+Apache/Nginx配置Rails Web程序也是主流之一。没想到如今竟然也支持Meteor了（其实不止Meteor，还支持Nodejs和Python）。从他的官网介绍中可以看到——A web server and application server for your web apps，其实就是整合了web服务器和后端语言所需要的各种依赖包。而且他的官网有非常详细的教程，本文就是按照此教程一步步走下来的，其中也记录了我部署过程中遇到的一些问题和解决方法。话不多说，首先奉上地址：Passenger官网 点我Meteor部署详细步骤地址 点我Github项目wiki地址 点我步骤一 选择一台云服务器国外一般用亚马逊或Digital Ocean的云服务器，这里我们就选择通用的运行Linux的服务器，配置差不多都一样。我使用的是阿里云运行Ubuntu14.04的服务器，当然CentOS也支持。步骤二 选择Passenger集成包官网总共提供了三种模式：与Nginx集成，与Apache集成，Standalone。三种模式的介绍与区别大家看官网，这里我选择了Nginx集成模式。步骤三 选择Passenger版本有开源版和企业版，企业版要收费的，所以我选择了open source。步骤四 安装Nodejs环境说明 以下都是在你买的服务器上操作的12345$ sudo apt-get update$ sudo apt-get install -y curl apt-transport-https ca-certificates &amp;&amp;curl --fail -ssL -o setup-nodejs https://deb.nodesource.com/setup_0.12 &amp;&amp;sudo bash setup-nodejs &amp;&amp;sudo apt-get install -y nodejs build-essential经过此过程，安装的Nodejs版本是0.12.10，大家也可以从NodeSource安装其他的版本如v4.3.1，或者使用nvm版本管理脚本。不过一开始在我尝试使用更高的版本时，老是出问题，后来发现Meteor不支持更高的Nodejs版本，所以大家尽量使用v0.12或者以下的版本吧！另外，使用nvm版本管理安装的Nodejs，其实安装到了你的用户目录下，以后使用不需要sudo命令，方便。而上面的步骤会全局安装Nodejs，以后安装包时，会出现权限问题，大家自行选择。步骤五 安装Passenger还是先选择你的服务器安装的系统类型和版本，这里我选择的是Ubuntu14.04.开始安装：12345678# 添加钥匙和apt包sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 561F9B9CAC40B2F7sudo apt-get install -y apt-transport-https ca-certificatessudo sh -c &apos;echo deb https://oss-binaries.phusionpassenger.com/apt/passenger trusty main &gt; /etc/apt/sources.list.d/passenger.list&apos;sudo apt-get update# 安装Passenger和Nginxsudo apt-get install -y nginx-extras passenger安装完成后,打开vim /etc/nginx/nginx.conf,并取消下面两行的注释：12# passenger_root /some-filename/locations.ini;# passenger_ruby /usr/bin/passenger_free_ruby;然后重启Nginx服务器：1sudo service nginx restart查看是否安装成功：1sudo /usr/bin/passenger-config validate-install查看Passenger运行情况(不是必须)：1sudo /usr/sbin/passenger-memory-stats最后重新执行一下：12sudo apt-get updatesudo apt-get upgrade目前都还是准备工作，下面开始上正餐了。步骤六 部署Meteor App说明 以下操作是在你的本地机器上首先打包你的Meteor程序包meteor bundle package.tar.gz,此处使用的是bundle命令，会出现提示说这个命令已经被build命令取代了，不过这里因为build命令会把iOS and Android移动平台的包一起打包进去，而我们并不需要。package.tar.gz是你取的压缩包的名字和格式。执行结束后，会在当前目录下生成。然后传到服务器上：123scp package.tar.gz adminuser@yourserver.com:# 例如（最好使用IP地址，注意最后的冒号）scp package.tar.gz root@120.24.72.4:登陆到服务器：ssh root@120.24.72.4(需要先下载ssh)说明 以下操作是在你的远程服务器上首先创建一个普通用户如blog（如果你以前已经创建过，可以省略这一步），按照提示输入密码（注意：不是你的root账户密码）1adduser blog然后确保以后可以不用密码登陆服务器（不是必须）123456sudo mkdir -p ~blog/.sshtouch $HOME/.ssh/authorized_keyssudo sh -c &quot;cat $HOME/.ssh/authorized_keys &gt;&gt; ~blog/.ssh/authorized_keys&quot;sudo chown -R blog: ~blog/.sshsudo chmod 700 ~blog/.sshsudo sh -c &quot;chmod 600 ~blog/.ssh/*&quot;现在blog用户是没有root权限的，不能使用sudo命令，最好把blog添加到sudoers里，输入visudo，找到：12# User privilege specificationroot ALL=(ALL:ALL) ALL在下面添加一句：123# User privilege specificationroot ALL=(ALL:ALL) ALLblog ALL=(ALL:ALL) ALL切换到blog用户（以后直接使用这个用户就行，不用在使用root）1sudo -u blog -H bash -l然后你就能使用sudo命令了，注意，你的root用户密码不要和你的普通用户密码一样，以后需要输入密码时，直接输入普遍用户的密码就可以了，不需要再使用root用户的密码。接下来：123456# 创建程序使用的目录（名字任意）sudo mkdir -p /var/www/blog# 然后进入cd /var/www/blog/# 解压到此目录sudo tar zxf ~/package.tar.gz安装mongodb1sudo apt-get install -y mongodb此处最好进入到/bundle目录下，创建两个空目录,后面要用到public目录，而tmp目录可以创建restart.txt文件，用于Nginx重启（现在不需要）：1mkdir tmp public接着进入到cd /programs/server目录下，执行：1sudo npm install --production安装完成后，创建Nginx配置文件：12sudo vim /etc/nginx/sites-enabled/blog.conf# 后面的文件名任意写入如下内容：12345678910111213141516171819server &#123; listen 80; server_name yourserver.com; # 写你的域名 或者直接写IP # 你的程序的public目录，就是刚才创建的空目录 root /var/www/blog/bundle/public; # 开启Passenger passenger_enabled on; # 说明是个meteor app passenger_app_type node; passenger_startup_file main.js; # MongoDB的位置，此处不用改就可以，后面的文件名任意，但不能有&apos;.&apos;，如myapp.db passenger_env_var MONGO_URL mongodb://localhost:27017/blogdb; # 你的根url，也可以是IP passenger_env_var ROOT_URL http://yourserver.com;&#125;最后重启Nginx1sudo service nginx restart然后你可以访问你的网站了：如果能直接访问，那只有恭喜你了如果显示500错误，说明Passenger配置过程出错，没有启动，你可以再仔细从头来一遍如果出现Passenger提示的错误信息，如We&#39;re sorry, but something went wrong.说明Passenger启动了，但是程序内部有误，我就是在第三种情况下困扰了好久，这时就要查看Nginx错误日志了：1sudo cat /var/log/nginx/error.log也可以查看Passenger的输出信息，在/var/log/目录下，有很多html文件，你可以用cat命令查看。然后根据错误信息Google之，可能遇到的问题不一样，下面是我遇到的：1234567891011121314151617/your-app-path/bundle/programs/server/node_modules/fibers/future.js:245 throw(ex); ^Error: Module did not self-register. at Error (native) at Module.load (module.js:355:32) at Function.Module._load (module.js:310:12) at Module.require (module.js:365:17) at require (module.js:384:17) at bindings (/your-app-path/bundle/programs/server/npm/npm -bcrypt/node_modules/bcrypt/node_modules/ bindings/bindings.js:74:15) at Object.&amp;lt;anonymous&amp;gt; (/your-app-path/bundle/programs/server/npm/ npm-bcrypt/node_modules/bcrypt/bcrypt.js:3:35) at Module._compile (module.js:460:26) at Object.Module._extensions..js (module.js:478:10) at Module.load (module.js:355:32)在网上搜了许多方法，归纳一下就是这两个包fibers和bcrypt的依赖关系，需要重新安装，不过我试了N多遍，还是不行，就在我要放弃的时候，又重新仔细看了一遍错误原因，才发现bcrypt这个包的位置不在bundle/programs/server/node_modules/目录下，而是在/bundle/programs/server/npm/npm-bcrypt/node_modules/目录下，然后瞬间看到一丝希望，赶忙删除/bcrypt这个目录，重新运行npm install bcrypt安装了新的包，最后重启Nginx，访问我的域名，真的就成功了。此刻，我真的想哭。泪的教训：看错误日志一定要仔细，仔细，再仔细总结一下：运行npm install --production后，fibers和bcrypt这两个包应该就在正确的位置了但由于依赖问题（我猜）不能工作，安装的fibers的版本是1.0.5，bcrypt的版本是0.7.8所以我只把/bundle/programs/server/npm/npm-bcrypt/node_modules/目录下的/bcrypt文件夹删除然后重新安装npm install bcrypt（注意是在这目录下），就会安装0.8.5版本的bcrypt了然后问题就能解决，最后重启Nginx注意我没有重新安装fibers包步骤七 你的程序需要更新时当我们更新程序后，需要上传新的打包好的文件，并再次部署，也可以编写自动化脚本，帮助你处理。这部分内容请大家直接看官网的步骤，我这里不再赘述了。接下来Passenger还能做更多，比如一台服务器可以同时运行多个Meteor app，监控你的内存和CPU，更多的配置项和优化功能，错误处理和调试等。总结可以看到，使用Passenger真的很方便，不用再头疼Nginx 的配置了，极大地节省了你的时间，强烈推荐大家使用。如果你遇到了其他问题，并且不能解决，可以联系我。","tags":[{"name":"meteor","slug":"meteor","permalink":"http://wuyang910217.github.io/tags/meteor/"},{"name":"passenger","slug":"passenger","permalink":"http://wuyang910217.github.io/tags/passenger/"}]},{"title":"hexo+indigo搭建materail design风格的博客网站","date":"2016-08-05T11:19:30.000Z","path":"2016/08/05/hexo-blog-theme-by-indigo.html","text":"简介现在使用hexo搭建一个静态blog网站真是几分钟的事，并且各种主题随意使用，对于不想折腾，仅仅作为一个记录工作和学习的工具，实在是太适合了．下面是一些配置文件的记录．这里我使用的是谷歌materail design风格的主题indigo，项目地址：githubhexo安装与常见命令123456789101112// 全局安装hexo，Linux系统可能需要sudo权限npm install hexo-cli -g// 新建项目命名为bloghexo init blog// 后面不用加.mdhexo new &apos;post-title&apos;// 本地启动hexo serverhexo cleanhexo generatehexo deploy配置文件在_config.yml文件中，可以修改大部分配置信息，另外一些要在themes/indigo/_config.yml文件中进行修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: wuyang的个人博客subtitle: Live long and Prosper!description: -记录学习和生活过程-author: wuyangemail: wuyang910217@gmail.comkeywords: meteor react booklanguage: zh-CNtimezone: Asia/Shanghaifeed: type: atom path: atom.xml limit: 0jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: trueneat_enable: trueneat_html: enable: true exclude:neat_css: enable: true exclude: - '*.min.css'neat_js: enable: true mangle: true output: compress: exclude: - '*.min.js'sitemap: path: sitemap.xml# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://wuyang910217.github.io/root: /permalink: :year/:month/:day/:title.htmlpermalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: indigo# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/wuyang910217/wuyang910217.github.io.git branch: master123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# hexo-theme-indigo# https://github.com/yscoder/hexo-theme-indigoversion: 1.1.7#添加新菜单项遵循以下规则# menu:# link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须# text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写# url: /about 链接，绝对或相对路径，必须。# target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: text: 归档 url: /archives tags: text: 标签 url: /tags th-list: text: 分类 url: /categories github: url: https://github.com/wuyang910217 target: _blank twitter: url: https://twitter.com/wuyangJT target: _blankrss: /atom.xml#你的头像urlavatar: /img/logo.jpg#faviconfavicon: /favicon.ico# emailemail: wuyang910217@gamil.com# 设置 Android L Chrome 浏览器状态栏颜色color: '#3F51B5'# 页面标题tags_title: tagsarchives_title: archivescategories_title: categories# 文章截断excerpt_render: falseexcerpt_length: 150excerpt_link: 阅读全文...mathjax: falsearchive_yearly: true#是否开启分享share: true#是否开启打赏，关闭 reward: falsereward: title: 谢谢打赏~ wechat: /img/wechat.png #微信，关闭设为 false alipay: /img/alipay.png #支付宝，关闭设为 false#是否开启搜索search: true#是否大屏幕下文章页隐藏导航hideMenu: true#是否开启toc#toc: falsetoc: list_number: true # 是否显示数字排序#文章页版权声明内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.iocopyright: 转载请注明出处：&lt;a href=\"&lt;%- url_for(page.path).replace(/index\\.html$/, '') %&gt;\" target=\"_blank\" rel=\"external\"&gt;&lt;%- url.replace(/index\\.html$/, '') %&gt;&lt;/a&gt;#站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447cnzz: false# Miscellaneousgoogle_analytics: truegoogle_site_verification: true# lessless: compress: true paths: - source/css/style.less#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-keyduoshuo: false#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论disqus_shortname: wuyangwang# 规范网址# 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径# https://support.google.com/webmasters/answer/139066# 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.netcanonical: http://wuyang910217.github.io/# 版权起始年份since_year:在scaffolds/post.md文件下，让它生成默认的categories和tags：123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: default techtags: [hexo1,hexo2]---一些修改和总结在每个md文件的开头都有date，时间是可以修改的文章截取摘要：正文中添加，会截取其前面的内容，不加，默认为150个字可以添加有用的插件如SEO优化，字数统计等后记网上的教程很多，不过最好首先按照其官方文档和所使用的主题的文档进行操作，遇到问题再上网搜索解决办法．","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wuyang910217.github.io/tags/hexo/"},{"name":"indigo","slug":"indigo","permalink":"http://wuyang910217.github.io/tags/indigo/"}]}]